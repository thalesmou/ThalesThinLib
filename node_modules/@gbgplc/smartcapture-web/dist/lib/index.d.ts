import * as lit_html from 'lit-html';
import * as lit from 'lit';
import { LitElement } from 'lit';
import { Ref } from 'lit/directives/ref.js';
import { LottiePlayer } from '@lottiefiles/lottie-player';

type FaceDetectionHint = {
    notInitializedHint?: string;
    initializingHint?: string;
    faceNotFoundHint?: string;
    tooManyFacesHint?: string;
    faceAngleTooLargeHint?: string;
    probabilityTooSmallHint?: string;
    faceTooSmallHint?: string;
    faceCloseToBorderHint?: string;
};

declare enum FaceDetectionState {
    NotInitialized = "NOT_INITIALIZED",
    FaceNotFound = "FACE_NOT_FOUND",
    TooManyFaces = "TOO_MANY_FACES",
    FaceAngleTooLarge = "FACE_ANGLE_TOO_LARGE",
    ProbabilityTooSmall = "PROBABILITY_TOO_SMALL",
    FaceTooSmall = "FACE_TOO_SMALL",
    FaceCloseToBorder = "FACE_CLOSE_TO_BORDER"
}
declare class LiveFaceCamera extends LitElement {
    static readonly InitializeEventName: string;
    static readonly BeforeOpenEventName: string;
    static readonly OpenEventName: string;
    static readonly DetectEventName: string;
    static readonly BeforeCaptureEventName: string;
    static readonly CaptureEventName: string;
    static readonly CloseEventName: string;
    static readonly FailureEventName: string;
    /**
     * @deprecated Use 'InitializeEventName' instead. This will be removed in a feature release.
     */
    static readonly DetectorInitializeEventName: string;
    /**
     * @deprecated Use 'DetectEventName' instead. This will be removed in a feature release.
     */
    static readonly PreviewEventName: string;
    /**
     * @deprecated RetakeEventName will be removed in a future release and will have no replacement.
     */
    static readonly RetakeEventName: string;
    private readonly liveCameraRef;
    private readonly eventDispatcher;
    private lastDetectionState;
    private isFlashing;
    environment: 'development' | 'production';
    isOpen: boolean;
    hints: FaceDetectionHint | undefined;
    detectionState: FaceDetectionState;
    isInPreview: boolean;
    detectionText: (faceState: FaceDetectionState) => string;
    static readonly styles: lit.CSSResult;
    private isMobileDevice;
    connectedCallback(): void;
    private _handleBeforeUnload;
    private _handleVisibilityChange;
    private _handleFocus;
    private _handleBlur;
    private loadLibrary;
    disconnectedCallback(): void;
    private _handleOutsideClick;
    updated(changedProperties: Map<string, any>): void;
    private _onInitialized;
    private _onBeforeOpened;
    private _onOpened;
    private _onDetection;
    private _onBeforeCaptured;
    private _onCaptured;
    private _onClosed;
    private _onFailure;
    private _onPreview;
    private _onRetake;
    private handleKeydown;
    private _closeCamera;
    liveCamera(): lit_html.TemplateResult<1>;
    render(): lit_html.TemplateResult<1>;
}
declare global {
    interface HTMLElementTagNameMap {
        'live-face-camera': LiveFaceCamera;
    }
}

type FaceCameraError = {
    code: number;
    message: string;
};
declare const PermissionNotGrantedError: (message: string) => FaceCameraError;
declare const UnexpectedError: (message: string) => FaceCameraError;

declare const resizeImageFromBlob: (imageBlob: Blob) => Promise<string>;
declare const resizeImageFromString: (imageSrc: string) => Promise<string>;

declare enum DocumentType {
    ID1 = 0,
    ID2 = 1,
    ID3 = 2,
    OTHER = 3,
    NONE = 4
}
declare enum DocumentState {
    SMALL_DOCUMENT = 0,
    OUT_OF_FRAME_DOCUMENT = 1,
    GOOD_DOCUMENT = 2
}
type Dimension = {
    width: number;
    height: number;
};
type Corner = {
    x: number;
    y: number;
};
type MappedCorners = {
    topLeft: Corner;
    topRight: Corner;
    bottomLeft: Corner;
    bottomRight: Corner;
};
type DetectResponse = {
    isGood: boolean;
    image?: ImageData;
    state?: DocumentState;
    dimensions?: Dimension;
    isAdequateDpi?: boolean;
    isSharp?: boolean;
    isGlareFree?: boolean;
    quality?: Object;
    coords?: Object;
    corners?: MappedCorners;
    failedChecks: String[];
};

type CaptureResponse = {
    isGood?: boolean;
    isAdequateDpi?: boolean;
    isSharp?: boolean;
    isGlareFree?: boolean;
    failedChecks?: String[];
    imageData?: ImageData;
    imageWidth?: number;
    imageHeight?: number;
    isPortraitOrientation?: boolean;
};

interface ISmartCaptureModule {
    isInitializing: boolean;
    isInitialized: boolean;
    /**
     * Initializes the Smart Capture Module
     * @returns true if init succeeds or if the module was already initialized, returns false if init was already called and is in progress.
     * @throws and error if initialize fails.
     */
    init: () => Promise<boolean>;
    detect: (imgData: CaptureResponse) => Promise<DetectResponse>;
    crop: (imgBlob: ArrayBuffer, captureData: DetectResponse) => Promise<ImageData>;
}

declare class SmartCaptureModule implements ISmartCaptureModule {
    #private;
    private constructor();
    static getInstance: () => SmartCaptureModule;
    private _initialized;
    get isInitialized(): boolean;
    private _initializing;
    get isInitializing(): boolean;
    private barcodeReaderId;
    private hiddenCanvas;
    init: () => Promise<boolean>;
    private addBarcodeReaderDiv;
    private processEncodedFrame;
    private mapCorners;
    private imageDataToBlob;
    detect: (imgData: CaptureResponse) => Promise<DetectResponse>;
    crop: (imgBlob: ArrayBuffer, captureData: DetectResponse) => Promise<ImageData>;
}

declare class SmartCaptureWorker {
    private smartCapture?;
    private workerGlobalContext;
    constructor(workerGlobalContext: any);
    private postMessage;
    private onError;
    private onMessage;
    private onInitialize;
    private onPerformQualityCheck;
    private resolveCheck;
    private checkQuality;
}

/**
 * @public
 */
type IImageResult = {
    /**
     * @public
     */
    quality: {
        blurCheck?: boolean;
        glareCheck?: boolean;
        resolutionCheck?: boolean;
        coordinateCheck?: boolean;
    };
    /**
     * @public
     */
    image: Uint8Array;
    /**
     * @public
     */
    coords: {
        height: number;
        width: number;
        x: number;
        y: number;
    };
    /**
     * @public
     */
    isGood: boolean;
    /**
     * @public
     */
    failedChecks: String[];
};

declare class SmartCaptureHost {
    private smartCaptureWorker?;
    createWorker: (workerScriptUrl: string) => Promise<void>;
    private createCrossDomainWorker;
    private createWorkerFallback;
    checkImage: (image: any) => Promise<IImageResult>;
    private makeRequest;
    private testSameOrigin;
}

type DocCameraError = {
    code: string;
    message: string;
};
declare const SequenceBreak: (isIOS?: boolean) => DocCameraError;
declare const StartFail: (message: string) => DocCameraError;
declare const RuntimeError: (message: string) => DocCameraError;
declare const HeicNotSupported: (message?: string) => DocCameraError;

declare enum CameraState {
    MoveCloser = 0,
    OutOfFrame = 1,
    FixGlare = 2,
    FixBlur = 3,
    Countdown = 4,
    Capturing = 5,
    TapToCapture = 6
}
declare class WebRtcCamera {
    private hiddenCanvas;
    private hiddenContext;
    private isStarted;
    private isDetecting;
    private detectTimeout?;
    private isCapturing;
    private parent;
    private smartCaptureModule;
    private player?;
    private lastFrameDetected;
    private restartDetectionBind;
    private visibilityChangeBind;
    private metaDataBind;
    runDetectionBind: () => void;
    constructor(parent: ILiveDocumentCamera, smartCaptureModule: ISmartCaptureModule);
    private initSmartCapture;
    private videoConstraints;
    private cameraConstraints;
    private finalizeCameraConstraints;
    startCamera(): Promise<void>;
    /**
     * Attempts to get the best back facing camera and then start it.
     *
     * getDevice will not always return accurate data until after get user media has been called once. So the first time this is called it starts the camera fitting the constraints, but after starting that camera it checks with get devices if there is a better camera fitting our constraints. If there is it will add its ID to the constraints can perform this function again, this time not checking with get devices.
     *
     * @param iteration the current attempt number to search for the proper camera device.
     */
    private startCameraInternal;
    private enableCamera;
    stopDetection(): void;
    endCamera(): void;
    private addEvents;
    private removeEvents;
    private runDetection;
    private getDevice;
    private onLoadedMetaData;
    private onVisibilityChange;
    private restartDetectionAfterBrowserResume;
    private stopMediaTracks;
    private sequenceBreak;
    private processFrameForDetection;
    private detect;
    private handleLiveCapture;
    triggerCapture(manualMode?: boolean): Promise<void>;
}

interface ILiveDocumentCamera {
    /**
     * The video element to which the camera stream should be rendered.
     */
    getPlayer(): HTMLVideoElement | undefined;
    /**
     * Called after the player is assigned a stream from the device's camera.
     * At the end of this function you should call play on the stream video element.
     * Calling play will start the detection loop and start issuing onDetect callbacks.
     */
    onCameraEnabled(): void;
    /**
     * Called after any fatal error. You most likely want to use this to close the camera and present the error to the user.
     */
    onError: (error: DocCameraError) => void;
    /**
     * Called after each detection.
     */
    onDetect: (response: DetectResponse | undefined, cameraState: CameraState) => void;
    /**
     * Called after capture is performed.
     */
    onCapture: (response: CaptureResponse) => void;
}

type DocumentHint = {
    title: string;
    description: string;
};

type DocumentDetectionHint = {
    moveCloserHint?: DocumentHint;
    fixBlurHint?: DocumentHint;
    fixGlareHint?: DocumentHint;
    outOfFrameHint?: DocumentHint;
    capturingHint?: DocumentHint;
};

declare class LiveDocumentCamera extends LitElement implements ILiveDocumentCamera {
    private tabbableElements;
    setFocusToElement(elementId: string): void;
    private elementsDisabled;
    private enableTabbingOnOtherElements;
    private disableTabbingOnOtherElements;
    toggleLottieAnimation(event: Event): void;
    static OpenEventName: string;
    static CloseEventName: string;
    static CaptureEventName: string;
    static DetectEventName: string;
    static FailureEventName: string;
    static styles: lit.CSSResult[];
    private handleKeydown;
    isOpen: boolean;
    showHelpIcon: boolean;
    forceManualCamera: boolean;
    useHeic: boolean;
    texts: {
        autoCaptureText: string;
        autoCaptureOnText: string;
        autoCaptureOffText: string;
        alertText: string;
    };
    generalInfoTexts: string[];
    hints: DocumentDetectionHint | undefined;
    successTime: number;
    showToggle: boolean;
    toggleAutoCaptureDelay: number;
    showBackOfDocumentAnimation: boolean;
    cameraState: CameraState;
    hasShownDocumentAnimation: boolean;
    toggleDelayIsDone: boolean;
    isPortraitOrientation: boolean;
    private tapToCaptureSpinner;
    private tapToCapture;
    showHelp: boolean;
    private captured;
    updateHint(): void;
    detectionHints: (docState: CameraState) => DocumentHint;
    private videoElementRef;
    private uiCanvasElementRef;
    private guidanceIconRef;
    private documentAnimationRef;
    documentBackAnimationRef: Ref<LottiePlayer>;
    private autoCaptureSwitchRef;
    private isPortraitOrientationQuery;
    smartCaptureModule?: ISmartCaptureModule;
    private webRtcCamera?;
    private eventDispatcher;
    getPlayer(): HTMLVideoElement | undefined;
    drawAutoCaptureFrame(autoCapture?: Boolean, autoCaptureToggled?: boolean): void;
    private loadHintAnimation;
    onDocumentAnimationComplete(): void;
    private onOrientationChange;
    private onTapToCaptureSwitchChange;
    private onTapToCaptureButtonClick;
    onCameraEnabled(): void;
    onDetect(response: DetectResponse | undefined, cameraState: CameraState): void;
    onCapture(response: CaptureResponse): void;
    onError(error: DocCameraError): void;
    openCamera(): void;
    private closeCamera;
    private helpToggle;
    connectedCallback(): void;
    disconnectedCallback(): void;
    updated(changedProperties: Map<string, any>): void;
    private guidanceIcon;
    private documentAnimation;
    private backOfDocumentAnimation;
    private manualActionsSection;
    private generalInfoSection;
    private manualCaptureButtonSection;
    private cameraGuidanceSection;
    private video;
    private cameraPreview;
    private helpSection;
    render(): lit_html.TemplateResult<1>;
}

type SDKMetadata = {
    make?: string;
    model?: string;
    software?: string;
    imageDescription?: string;
    dateTimeOriginal?: string;
    userComment?: string;
};
declare function addMetadata(imgBase64: string, metadata?: SDKMetadata): any;

declare const isIpadIOS13OrAbove: () => boolean;
declare const isIOS: () => boolean;
declare const iOSversion: () => number[];
declare const isiOS144Plus: () => boolean;
declare const isiOS15: () => boolean;
declare function isiOS163OrLess(): boolean;
declare function isiOS164Plus(): boolean;
declare function isiOS17(): boolean;
declare const isDeviceAffectedByIOS16Issue: () => boolean;
declare const isFirefox: () => boolean;
declare const isSamsungNote10OrS10OrNewer: () => Promise<boolean>;
declare const isChromeForIOS: () => boolean;
declare const isLiveCaptureSupported: () => boolean;
declare const isBackCameraLabel: (cameraLabel: string) => boolean;
declare const arrayBufferToBase64: (buffer: ArrayBuffer) => string;
declare const deviceOS: () => string;
declare const sdkName = "Docs & Bio Mobile Web SDK 1.0";

type SdkBasicAuthentication = {
    username: string;
    password: string;
    subscriptionId: string;
    url: string;
};

type SdkBearerAuthentication = {
    token: string;
    url: string;
};

declare const isSdkBearerAuthentication: (value: any) => value is SdkBearerAuthentication;
declare const getSubscription: (token: string) => string;

export { CameraState, DocumentState, DocumentType, HeicNotSupported, LiveDocumentCamera, LiveFaceCamera, PermissionNotGrantedError, RuntimeError, SequenceBreak, SmartCaptureHost, SmartCaptureModule, SmartCaptureWorker, StartFail, UnexpectedError, WebRtcCamera, addMetadata, arrayBufferToBase64, deviceOS, getSubscription, iOSversion, isBackCameraLabel, isChromeForIOS, isDeviceAffectedByIOS16Issue, isFirefox, isIOS, isIpadIOS13OrAbove, isLiveCaptureSupported, isSamsungNote10OrS10OrNewer, isSdkBearerAuthentication, isiOS144Plus, isiOS15, isiOS163OrLess, isiOS164Plus, isiOS17, resizeImageFromBlob, resizeImageFromString, sdkName };
export type { Corner, DetectResponse, Dimension, DocCameraError, DocumentHint, FaceCameraError, MappedCorners, SDKMetadata, SdkBasicAuthentication, SdkBearerAuthentication };
