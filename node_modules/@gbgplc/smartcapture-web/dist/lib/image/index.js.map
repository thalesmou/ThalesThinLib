{"version":3,"file":"index.js","sources":["../../../../src/image/resizer.ts","../../../../src/image/DetectResponse.ts","../../../../src/image/smart-capture/SmartCaptureHost.ts","../../../../src/image/SmartCaptureModule.ts","../../../../src/image/smart-capture/SmartCaptureWorker.ts"],"sourcesContent":["const onload: (imageElement: HTMLImageElement) => string = (\n  imageElement: HTMLImageElement\n) => {\n  const canvasElement = document.createElement('canvas');\n  let MAX_WIDTH = 1080;\n  let MAX_HEIGHT = 720;\n  const { width, height } = imageElement;\n  const context = canvasElement.getContext('2d');\n\n  const smallerDimension = width > height ? height : width;\n\n  if (smallerDimension > MAX_HEIGHT) {\n    if (width < height) {\n      const aspectRatio = height / width;\n      MAX_WIDTH = MAX_HEIGHT;\n      MAX_HEIGHT = MAX_WIDTH * aspectRatio;\n    } else {\n      const aspectRatio = width / height;\n      MAX_WIDTH = MAX_HEIGHT * aspectRatio;\n    }\n  } else {\n    MAX_WIDTH = imageElement.width;\n    MAX_HEIGHT = imageElement.height;\n  }\n\n  canvasElement.width = MAX_WIDTH;\n  canvasElement.height = MAX_HEIGHT;\n\n  context?.drawImage(imageElement, 0, 0, MAX_WIDTH, MAX_HEIGHT);\n  const data = canvasElement.toDataURL('image/jpeg', 0.8);\n  context?.clearRect(0, 0, MAX_WIDTH, MAX_HEIGHT);\n  return data;\n};\n\nexport const resizeImageFromBlob = (imageBlob: Blob): Promise<string> =>\n  new Promise(resolve => {\n    const imageElement = document.createElement('img');\n\n    imageElement.onload = () => {\n      const data = onload(imageElement);\n      URL.revokeObjectURL(imageElement.src);\n      resolve(data);\n    };\n    imageElement.src = URL.createObjectURL(imageBlob);\n  });\n\nexport const resizeImageFromString = (imageSrc: string): Promise<string> =>\n  new Promise(resolve => {\n    const imageElement = document.createElement('img');\n\n    imageElement.onload = () => {\n      const data = onload(imageElement);\n      resolve(data.split('base64,')[1]);\n    };\n    imageElement.src = imageSrc;\n  });\n","export enum DocumentType {\n  ID1,\n  ID2,\n  ID3,\n  OTHER,\n  NONE,\n}\n\nexport enum DocumentState {\n  SMALL_DOCUMENT,\n  OUT_OF_FRAME_DOCUMENT,\n  GOOD_DOCUMENT,\n}\n\nexport type Dimension = {\n  width: number;\n  height: number;\n};\n\nexport type Corner = {\n  x: number;\n  y: number;\n};\n\nexport type MappedCorners = {\n  topLeft: Corner;\n  topRight: Corner;\n  bottomLeft: Corner;\n  bottomRight: Corner;\n};\n\nexport type DetectResponse = {\n  isGood: boolean;\n  image?: ImageData;\n  state?: DocumentState;\n  dimensions?: Dimension;\n  isAdequateDpi?: boolean;\n  isSharp?: boolean;\n  isGlareFree?: boolean;\n  quality?: Object;\n  coords?: Object;\n  corners?: MappedCorners;\n  failedChecks: String[];\n};\n","/* eslint no-promise-executor-return: 0 */\nimport { SmartCaptureWorkerMessages } from './enums/SmartCaptureWorkerMessages';\nimport { IImageResult } from './interfaces/IImage';\nimport { IWorkerMessageEvent } from './interfaces/IMessage';\n\nexport class SmartCaptureHost {\n  private smartCaptureWorker?: Worker;\n\n  public createWorker = (workerScriptUrl: string): Promise<void> =>\n    new Promise((resolve, reject) => {\n      if (this.smartCaptureWorker) {\n        return this.makeRequest(SmartCaptureWorkerMessages.Initialize, null)\n          .then(resolve)\n          .catch(reject);\n      }\n      this.smartCaptureWorker = this.createCrossDomainWorker(workerScriptUrl);\n      return this.makeRequest(SmartCaptureWorkerMessages.Initialize, null)\n        .then(resolve)\n        .catch(reject);\n    });\n\n  private createCrossDomainWorker(workerUrl: string): Worker | undefined {\n    let worker;\n    try {\n      if (this.testSameOrigin(workerUrl)) {\n        worker = new Worker(workerUrl, { type: 'module' });\n        worker.onerror = event => {\n          event.preventDefault();\n          worker = this.createWorkerFallback(workerUrl);\n        };\n      } else {\n        worker = this.createWorkerFallback(workerUrl);\n      }\n    } catch (_) {\n      worker = this.createWorkerFallback(workerUrl);\n    }\n    return worker;\n  }\n\n  private createWorkerFallback(workerUrl: string): Worker | undefined {\n    let worker;\n    try {\n      let blob;\n      try {\n        // TODO: This does not work as expected. We cannot use importScripts with module\n        blob = new Blob([`importScripts('${workerUrl}');`], { type: 'module' });\n      } catch (_) {\n        const blobBuilder = new ((window && (window as any).BlobBuilder) ||\n          (window && (window as any).WebKitBlobBuilder) ||\n          (window && (window as any).MozBlobBuilder))();\n        blobBuilder.append(`importScripts('${workerUrl}');`);\n        blob = blobBuilder.getBlob('module');\n      }\n\n      const url =\n        (window && (window as any).URL) ||\n        (window && (window as any).webkitURL);\n      const blobUrl = url.createObjectURL(blob);\n      return new Worker(blobUrl);\n    } catch (e1) {\n      console.log('WorkerFallback', e1);\n    }\n    return worker;\n  }\n\n  public checkImage = (image: any): Promise<IImageResult> =>\n    this.makeRequest(SmartCaptureWorkerMessages.PerformQualityCheck, { image });\n\n  private makeRequest = <InputType = any, OutputType = any>(\n    requestMessage: SmartCaptureWorkerMessages,\n    requestData: InputType,\n    requestId: string = new Date().getTime().toString()\n  ): Promise<OutputType> =>\n    new Promise((resolve, reject) => {\n      if (this.smartCaptureWorker) {\n        const responseHandler = ({ data }: IWorkerMessageEvent<OutputType>) => {\n          if (data.id === requestId) {\n            this.smartCaptureWorker!.removeEventListener(\n              'message',\n              responseHandler\n            );\n            this.smartCaptureWorker!.removeEventListener('error', errorHandler);\n\n            switch (data.message) {\n              case SmartCaptureWorkerMessages.Error:\n                return reject();\n              default:\n                return resolve(data.data);\n            }\n          }\n          return reject();\n        };\n\n        const errorHandler = (e: any) => {\n          this.smartCaptureWorker!.removeEventListener(\n            'message',\n            responseHandler\n          );\n          this.smartCaptureWorker!.removeEventListener('error', errorHandler);\n          return reject(e);\n        };\n\n        this.smartCaptureWorker.addEventListener('message', responseHandler);\n        this.smartCaptureWorker.addEventListener('error', errorHandler);\n\n        this.smartCaptureWorker!.postMessage({\n          id: requestId,\n          message: requestMessage,\n          data: requestData,\n        });\n      } else {\n        reject();\n      }\n    });\n\n  private testSameOrigin(url: string) {\n    const loc = window.location;\n    const a = document.createElement('a');\n    a.href = url;\n    return (\n      a.hostname === loc.hostname &&\n      a.port === loc.port &&\n      a.protocol === loc.protocol\n    );\n  }\n}\n\n// TODO: Ideally this string wants to come from webpack...\nexport default new SmartCaptureHost();\n","/* eslint no-promise-executor-return: 0 */\n/* eslint prefer-promise-reject-errors: 0 */\n/* eslint consistent-return: 0 */\nimport SmartCaptureHost from './smart-capture/SmartCaptureHost';\nimport { DetectResponse, MappedCorners } from './DetectResponse';\nimport { ISmartCaptureModule } from './interfaces/ISmartCaptureModule';\nimport { CaptureResponse } from '../document/CaptureResponse';\n\nexport class SmartCaptureModule implements ISmartCaptureModule {\n\n  static #instance: SmartCaptureModule | undefined;\n\n  private constructor() {\n    this.addBarcodeReaderDiv(this.barcodeReaderId);\n  }\n\n\n  static getInstance: () => SmartCaptureModule = () => {\n    if (!SmartCaptureModule.#instance) {\n      SmartCaptureModule.#instance = new SmartCaptureModule();\n    }\n    return SmartCaptureModule.#instance;\n  };\n\n  private _initialized = false;\n  get isInitialized() {\n    return this._initialized;\n  }\n  private _initializing = false;\n  get isInitializing() {\n    return this._initializing;\n  }\n\n  private barcodeReaderId: string = 'barcode-reader';\n\n  private hiddenCanvas: HTMLCanvasElement = document.createElement('canvas');\n\n  init: () => Promise<boolean> = async () => {\n    if (this._initialized) {\n      return true;\n    }\n    if (!this._initializing) {\n      this._initializing = true;\n      const workerScriptUrl = new URL(__WORKER_PATH__, import.meta.url).href;\n      try {\n        await SmartCaptureHost.createWorker(workerScriptUrl);\n        this._initializing = false;\n        this._initialized = true;\n        return true;\n      } catch {\n        this._initializing = false;\n        this._initialized = false;\n        throw new Error('Create Worker Failed');\n      }\n    } else {\n      return false;\n    }\n  };\n\n  private addBarcodeReaderDiv: (barcodeReaderId: string) => void = (\n    barcodeReaderId: string\n  ) => {\n    if (document.getElementById(barcodeReaderId)) {\n      return;\n    }\n    const barcodeReaderDiv = document.createElement('div');\n    barcodeReaderDiv.id = barcodeReaderId;\n    barcodeReaderDiv.style.display = 'none';\n    document.body.appendChild(barcodeReaderDiv);\n  };\n\n  private processEncodedFrame: (img: ArrayBuffer) => Promise<DetectResponse> =\n    async (img: ArrayBuffer) => {\n      const result = await SmartCaptureHost.checkImage(img);\n      if (result && result.quality && result.coords) {\n        const corners = result.quality.coordinateCheck\n          ? this.mapCorners(result.coords)\n          : undefined;\n        const dimensions = {\n          width: result.coords.width,\n          height: result.coords.height,\n        };\n        // let type = DocumentType.ID1; //todo how can we detect this now\n        const response: DetectResponse = {\n          isGood: result.isGood,\n          // type: type,\n          dimensions,\n          isAdequateDpi: result.quality.resolutionCheck,\n          // isCorrectAspectRatio: this.isCorrectAspectRatio(dimensions, type),\n          corners,\n          isSharp: result.quality.blurCheck,\n          isGlareFree: result.quality.glareCheck,\n          failedChecks: result.failedChecks,\n        };\n        return response;\n      }\n      throw new Error('Part of result was null');\n    };\n\n  // private isCorrectAspectRatio(dimens: Dimension, cardType: DocumentType) {\n  //   let aspectRatio = dimens.width/dimens.height;\n  //   let isCorrectAspectRatio = false;\n  //   let tolerancePercentage = 5.0;\n  //   let expectedPassportAspectRatio = 1.42;\n  //   let expectedID1AspectRatio = 1.58870;\n  //   let expectedID2AspectRatio  = 1.41915551;\n  //   if (cardType == DocumentType.ID3) {\n  //     let min = ((100 - tolerancePercentage) / 100) * expectedPassportAspectRatio;\n  //     let max = ((100 + tolerancePercentage) / 100) * expectedPassportAspectRatio;\n  //     if (aspectRatio >= min && aspectRatio <= max) {\n  //       isCorrectAspectRatio = true;\n  //     }\n  //   } else if (cardType == DocumentType.ID1) {\n  //     let min = ((100 - tolerancePercentage) / 100) * expectedID1AspectRatio;\n  //     let max = ((100 + tolerancePercentage) / 100) * expectedID1AspectRatio;\n  //     if (aspectRatio >= min && aspectRatio <= max) {\n  //       isCorrectAspectRatio = true;\n  //     }\n  //   } else if (cardType == DocumentType.ID2) {\n  //     let min = ((100 - tolerancePercentage) / 100) * expectedID2AspectRatio;\n  //     let max = ((100 + tolerancePercentage) / 100) * expectedID2AspectRatio;\n  //     if (aspectRatio >= min && aspectRatio <= max) {\n  //       isCorrectAspectRatio = true;\n  //     }\n  //   }\n  //   return isCorrectAspectRatio;\n  // }\n\n  private mapCorners(coords: {\n    height: number;\n    width: number;\n    x: number;\n    y: number;\n  }): MappedCorners {\n    return {\n      topLeft: {\n        x: coords.x,\n        y: coords.y,\n      },\n      topRight: {\n        x: coords.x + coords.width,\n        y: coords.y,\n      },\n      bottomRight: {\n        x: coords.x + coords.width,\n        y: coords.y + coords.height,\n      },\n      bottomLeft: {\n        x: coords.x,\n        y: coords.y + coords.height,\n      },\n    };\n  }\n\n  private imageDataToBlob: (imageData: ImageData) => Promise<Blob> = async (\n    imageData: ImageData\n  ) => {\n    const w = imageData.width;\n    const h = imageData.height;\n    const { hiddenCanvas } = this;\n    const hiddenContext = this.hiddenCanvas.getContext('2d');\n\n    if (!hiddenContext) {\n      throw new Error('Hidden Context Missing');\n    }\n    hiddenCanvas.width = w;\n    hiddenCanvas.height = h;\n    hiddenContext.putImageData(imageData, 0, 0);\n    const blob: Blob | null = await new Promise(resolve =>\n      hiddenCanvas.toBlob(resolve)\n    );\n    if (blob) return blob;\n    throw new Error('Canvas To Blob Errored');\n  };\n\n  detect: (imgData: CaptureResponse) => Promise<DetectResponse> = async (\n    imgData: CaptureResponse\n  ) => {\n    if (imgData.imageData) {\n      const asBlob = await this.imageDataToBlob(imgData.imageData);\n      const buffer = await asBlob.arrayBuffer();\n      const result = await this.processEncodedFrame(buffer);\n      if (result.isGood) {\n        const croppedImg = await this.crop(buffer, result);\n        result.image = croppedImg;\n        return result;\n      }\n      return result;\n    }\n    throw new Error('Image Data Was Null');\n  };\n\n  crop: (\n    imgBlob: ArrayBuffer,\n    captureData: DetectResponse\n  ) => Promise<ImageData> = async (\n    imgBlob: ArrayBuffer,\n    captureData: DetectResponse\n  ) => {\n    if (!imgBlob || !captureData.corners) {\n      throw new Error('Image or Corners Missing');\n    }\n\n    const { hiddenCanvas } = this;\n    const hiddenContext = this.hiddenCanvas.getContext('2d');\n\n    if (!hiddenContext) {\n      throw new Error('Hidden Context Missing');\n    }\n\n    if (captureData.dimensions?.width && captureData.dimensions?.height) {\n      const blob = new Blob([imgBlob], { type: 'image/jpeg' });\n      const img = new Image();\n\n      const addImageProcess = (src: string) =>\n        new Promise<ImageData>((resolve, reject) => {\n\n          img.onload = function () {\n            if (captureData.corners) {\n              const top = Math.min(\n                captureData.corners.topLeft.y,\n                captureData.corners.topRight.y\n              );\n              const bot = Math.max(\n                captureData.corners.bottomLeft.y,\n                captureData.corners.bottomRight.y\n              );\n              const left = Math.min(\n                captureData.corners.topLeft.x,\n                captureData.corners.bottomLeft.x\n              );\n              const right = Math.max(\n                captureData.corners.topRight.x,\n                captureData.corners.bottomRight.x\n              );\n\n              hiddenCanvas.height = bot - top;\n              hiddenCanvas.width = right - left;\n              hiddenContext.drawImage(\n                img,\n                left,\n                top,\n                right - left,\n                bot - top,\n                0,\n                0,\n                hiddenCanvas.width,\n                hiddenCanvas.height\n              );\n              const data = hiddenContext.getImageData(\n                0,\n                0,\n                hiddenCanvas.width,\n                hiddenCanvas.height\n              );\n              hiddenContext.clearRect(\n                0,\n                0,\n                hiddenCanvas.width,\n                hiddenCanvas.height\n              );\n              hiddenCanvas.height = 1;\n              hiddenCanvas.width = 1;\n\n              resolve(data);\n            }\n          };\n          img.onerror = reject;\n          img.src = src;\n        });\n\n      return addImageProcess(URL.createObjectURL(blob));\n    }\n    throw new Error('Width or Height Missing');\n  };\n}\n","/* eslint camelcase: 0 */\n/* eslint no-promise-executor-return: 0 */\nimport stickman_module from '@gbgplc/stickman-wasm';\nimport { SmartCaptureWorkerMessages } from './enums/SmartCaptureWorkerMessages';\nimport { IWorkerMessageEvent, IWorkerMessage } from './interfaces/IMessage';\n\nexport class SmartCaptureWorker {\n  private smartCapture?: any;\n  private workerGlobalContext: any;\n\n  constructor(workerGlobalContext: any) {\n    this.workerGlobalContext = workerGlobalContext;\n\n    this.workerGlobalContext.addEventListener('message', this.onMessage);\n    this.workerGlobalContext.addEventListener('error', this.onError);\n  }\n\n  private postMessage = (\n    id: string,\n    message: SmartCaptureWorkerMessages,\n    data?: any\n  ): Promise<void> =>\n    new Promise(resolve =>\n      resolve(\n        this.workerGlobalContext.postMessage({\n          id,\n          message,\n          data,\n        } as IWorkerMessage)\n      )\n    );\n\n  private onError = (e: Error) =>\n    this.postMessage('', SmartCaptureWorkerMessages.Error, { ...e });\n\n\n  private onMessage = ({ data }: IWorkerMessageEvent) => {\n    switch (data.message) {\n      case SmartCaptureWorkerMessages.PerformQualityCheck:\n        return this.onPerformQualityCheck(data.id, data.data);\n      case SmartCaptureWorkerMessages.Terminate:\n        return this.postMessage(\n          data.id,\n          SmartCaptureWorkerMessages.Terminate\n        ).then(() => this.workerGlobalContext.close());\n      case SmartCaptureWorkerMessages.Initialize:\n        return this.onInitialize()\n          .then(() =>\n            this.postMessage(data.id, SmartCaptureWorkerMessages.ReadyToProcess)\n          )\n          .catch(() =>\n            this.postMessage(data.id, SmartCaptureWorkerMessages.Error)\n          );\n      default:\n    }\n  };\n\n  private onInitialize = () =>\n    new Promise(resolve => {\n      if (this.smartCapture) {\n        return resolve(this.smartCapture);\n      }\n      return stickman_module().then((smartCapture: any) => {\n        this.smartCapture = smartCapture;\n\n        return resolve(smartCapture);\n      });\n    });\n\n  private onPerformQualityCheck = (id: string, { image }: { image: any }) => {\n    this.checkQuality(image)\n      .then(response =>\n        this.postMessage(id, SmartCaptureWorkerMessages.CheckComplete, response)\n      )\n      .catch((e: any) =>\n        this.postMessage(id, SmartCaptureWorkerMessages.CheckFailed, e.message)\n      );\n  };\n\n  private resolveCheck = (\n    name: string,\n    succesfulChecks: any,\n    failedChecks: any\n  ) => {\n    const checkPassed = succesfulChecks.includes(name);\n    const checkFailed = failedChecks.includes(name);\n    if (!checkPassed && !checkFailed) {\n      return null;\n    }\n    return checkPassed;\n  };\n\n  private checkQuality = (image: any) => {\n    const smResult = this.smartCapture.analyse_encoded_image(image);\n    const { document_bounds, failed_checks, is_good, successful_checks } =\n      JSON.parse(smResult);\n    const result = Promise.resolve({\n      isGood: is_good,\n      quality: {\n        blurCheck: this.resolveCheck(\n          'BlurCheck',\n          successful_checks,\n          failed_checks\n        ),\n        glareCheck: this.resolveCheck(\n          'GlareCheck',\n          successful_checks,\n          failed_checks\n        ),\n        resolutionCheck: this.resolveCheck(\n          'LowResolutionCheck',\n          successful_checks,\n          failed_checks\n        ),\n        coordinateCheck: this.resolveCheck(\n          'FullDocumentInViewCheck',\n          successful_checks,\n          failed_checks\n        ),\n      },\n      failedChecks: failed_checks,\n      coords: document_bounds,\n    });\n\n    return result;\n  };\n}\n\nexport default new SmartCaptureWorker(self);\n"],"names":["onload","imageElement","canvasElement","document","createElement","MAX_WIDTH","MAX_HEIGHT","width","height","context","getContext","drawImage","data","toDataURL","clearRect","resizeImageFromBlob","imageBlob","Promise","resolve","URL","revokeObjectURL","src","createObjectURL","resizeImageFromString","imageSrc","split","DocumentType","DocumentState","SmartCaptureHost","constructor","this","createWorker","workerScriptUrl","reject","smartCaptureWorker","createCrossDomainWorker","makeRequest","then","catch","checkImage","image","requestMessage","requestData","requestId","Date","getTime","toString","responseHandler","id","removeEventListener","errorHandler","message","e","addEventListener","postMessage","workerUrl","worker","testSameOrigin","Worker","type","onerror","event","preventDefault","createWorkerFallback","_","blob","Blob","blobBuilder","window","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","append","getBlob","blobUrl","webkitURL","e1","console","log","url","loc","location","a","href","hostname","port","protocol","SmartCaptureHost$1","SmartCaptureModule","_initialized","_initializing","barcodeReaderId","hiddenCanvas","init","async","_b","Error","addBarcodeReaderDiv","getElementById","barcodeReaderDiv","style","display","body","appendChild","processEncodedFrame","img","result","quality","coords","corners","coordinateCheck","mapCorners","undefined","dimensions","isGood","isAdequateDpi","resolutionCheck","isSharp","blurCheck","isGlareFree","glareCheck","failedChecks","imageDataToBlob","imageData","w","h","hiddenContext","putImageData","toBlob","detect","imgData","asBlob","buffer","arrayBuffer","croppedImg","crop","imgBlob","captureData","_c","Image","top","Math","min","topLeft","y","topRight","bot","max","bottomLeft","bottomRight","left","x","right","getImageData","addImageProcess","isInitialized","isInitializing","_SmartCaptureModule_instance","value","getInstance","__classPrivateFieldGet","_a","__classPrivateFieldSet","SmartCaptureWorker","workerGlobalContext","onError","onMessage","onPerformQualityCheck","close","onInitialize","smartCapture","stickman_module","checkQuality","response","resolveCheck","name","succesfulChecks","checkPassed","includes","checkFailed","smResult","analyse_encoded_image","document_bounds","failed_checks","is_good","successful_checks","JSON","parse","self"],"mappings":"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"}