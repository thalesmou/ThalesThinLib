<html lang="en">
<head>
    <title>v6.28</title>
    <link rel="shortcut icon" href="./images/favicon.png" />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1 viewport-fit=cover" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link rel="stylesheet" href="./css/bootstrap.min.css" />
    <link rel="stylesheet" href="./css/style.css" />
    <link rel="stylesheet" type="text/css" href="./css/animate.css" />
    <link rel="stylesheet" type="text/css" href="./css/select2.min.css" />
    <link rel="stylesheet" type="text/css" href="./css/perfect-scrollbar.css" />
    <link rel="stylesheet" type="text/css" href="./css/main.css" />
    <link href="./css/font-awesome.min.css" rel="stylesheet" />
</head>
<body id="background">
    <div class="container center">
        <div>
            <div class="col-md-12">
                <h2 id="mainheader" class="white">Test Page</h2>
                <p id="maintext" class="white">Initializing, please wait...</p>
            </div>
        </div>
        <div id="actionbox">
            <div class="col-md-6 col-md-offset-3 center">
                <div class="btn-container">
                    <h1 id="startBox" class="imgupload">
                        <i class="fa fa-cloud-upload"></i>
                    </h1>
                    <h1 id="OKBox" class="imgupload ok">
                        <i class="fa fa-check-circle"></i>
                    </h1>
                    <h1 id="NOKBox" class="imgupload stop">
                        <i class="fa fa-times-circle"></i>
                    </h1>
                    <h1 id="waitBox" class="imgupload wait">
                        <i class="fa fa-hourglass-half"></i>
                    </h1>
                    <h1 id="verifyBox">
                        <img id="verifyImage"
                             alt="Loading..."
                             style="
                  width: 100%;
                  height: 100%;
                  object-fit: contain;
                  max-height: 250px;
                " />
                    </h1>
                </div>
            </div>
        </div>
        <div id="deviceSelectorDiv" style="display: none">
            <div class="col-md-12">
                <p class="white">Select Device</p>
                <select style="width: 100%" id="deviceSelector"></select>
            </div>
        </div>
        <div class="col-md-12" style="margin-top: 10px">
            <button type="button"
                    id="mainbtn"
                    class="btn btn-primary btn-lg"
                    style="margin-left: 5px">
                Next
            </button>
            <button type="button"
                    id="secbtn"
                    class="btn btn-sm"
                    style="margin-left: 5px">
                Next
            </button>
            <button type="button"
                    id="thirdbtn"
                    class="btn btn-sm"
                    style="margin-left: 5px">
                Next
            </button>
            <div class="col-md-12" style="margin-top: 10px">
                <input id="apiId"
                       type="text"
                       autocomplete="on"
                       value=""
                       placeholder="API ID (if not in config file)"
                       style="width: 100%" />
            </div>
            <div class="col-md-12">
                <input id="apiKey"
                       type="password"
                       autocomplete="on"
                       value=""
                       placeholder="API Key (if not in config file)"
                       style="width: 100%" />
            </div>
        </div>
        <div class="col-md-12" style="margin-top: 10px"></div>
    </div>
    <div class="limiter" id="maintable">
        <div class="container-table100">
            <div class="wrap-table100" id="restable"></div>
        </div>
    </div>
    <input style="width: 100%"
           onClick="this.select();"
           value=""
           id="logger"
           name="logger"
           readonly />
    <script type="importmap">
        {
          "imports": {
            "idlive-face-capture-web-development": "./node_modules/@gbgplc/smartcapture-web/node_modules/idlive-face-capture-web-development/index.js",
            "idlive-face-capture-web": "./node_modules/@gbgplc/smartcapture-web/node_modules/idlive-face-capture-web/index.js",
            "@gbgplc/": "./node_modules/@gbgplc/",
            "@gbgplc/smartcapture-web": "./node_modules/@gbgplc/smartcapture-web/dist/lib/index.es.js",
            "@gbgplc/smartcapture-web/face": "./node_modules/@gbgplc/smartcapture-web/dist/lib/face/index.js",
            "@gbgplc/smartcapture-web/document": "./node_modules/@gbgplc/smartcapture-web/dist/lib/document/index.js",
            "@gbgplc/stickman-wasm": "./node_modules/@gbgplc/smartcapture-web/node_modules/@gbgplc/stickman-wasm/_builds/stickman.js",

            "tslib": "./node_modules/tslib/tslib.es6.js",
            "lit": "./node_modules/lit/index.js",
            "lit/": "./node_modules/lit/",
            "piexifjs": "./node_modules/piexifjs/piexif.js",
            "@lottiefiles/lottie-player": "./node_modules/@lottiefiles/lottie-player/dist/lottie-player.esm.js",
            "@imagemagick/magick-wasm": "./node_modules/@imagemagick/magick-wasm/dist/index.js",
            "@lit/reactive-element": "./node_modules/@lit/reactive-element/reactive-element.js",
            "@lit/reactive-element/": "./node_modules/@lit/reactive-element/",
            "lit-html": "./node_modules/lit-html/lit-html.js",
            "lit-html/": "./node_modules/lit-html/",
            "lit-element/": "./node_modules/lit-element/"
          }
        }
    </script>    
    <script type="module">
        import { ThalesThinLib } from "./ThalesThinLib.js"        
        //----------------------------------
        //---------- TEST APP CONFIG -------
        //----------------------------------
        //Settings from URL
        const hash = window.location.hash
            ? window.location.hash.substring(1)
            : null;
        let Credential = {};
        if (hash) {
            try {
                Credential = JSON.parse(
                    atob(hash.replace(/_/g, "/").replace(/-/g, "+"))
                );
            } catch (error) {
                console.log(error);
                Credential = {};
            }
        }
        let JPEG_QUALITY = Credential.JPEG_QUALITY || 1.0;
        let DO_VERIFICATION = Credential.DO_VERIFICATION || false;
        let PASS_PROXY = Credential.PASS_PROXY || false;
        let USER_PROXY = Credential.USER_PROXY || false;
        if (!USER_PROXY || !PASS_PROXY) {
            DO_VERIFICATION = false;
        }
        let SDK_USER = Credential.id_username;
        let SDK_PASS = Credential.id_password;
        let SDK_ENDPOINT = Credential.acas_endpoint;

        let CAPTURE_TIMEOUT = Credential.CAPTURE_TIMEOUT || null;
        let MAX_SDK_ATTEMPTS =
            Credential.MAX_SDK_ATTEMPTS !== undefined
                ? Credential.MAX_SDK_ATTEMPTS
                : null;
        let MAX_SERVER_ATTEMPTS =
            Credential.MAX_SERVER_ATTEMPTS !== undefined
                ? Credential.MAX_SERVER_ATTEMPTS
                : undefined;
        let MAX_VERIF_ATTEMPTS =
            Credential.MAX_VERIF_ATTEMPTS !== undefined
                ? Credential.MAX_VERIF_ATTEMPTS
                : undefined;
        let ACTION_BUTTON =
            Credential.ACTION_BUTTON || Credential.EXIT_ON_BACK || false;
        let DPI_THRESH =
            Credential.DPI_THRESH >= 0 ? Credential.DPI_THRESH : null;
        let MIN_DPI_THRESH =
            Credential.MIN_DPI_THRESH >= 0 ? Credential.MIN_DPI_THRESH : null;
        let GLARE_THRESH =
            Credential.GLARE_THRESH >= 0 ? Credential.GLARE_THRESH : null;
        let SHARPNESS_THRESH =
            Credential.SHARPNESS_THRESH >= 0 ? Credential.SHARPNESS_THRESH : null;             
        let DO_DEBUG = Credential.DO_DEBUG || false;
        let SPECIAL_DOUBLE_VERIF = Credential.SPECIAL_DOUBLE_VERIF || false;                
        let DO_SMART_CAPTURE = !!Credential.DO_SMART_CAPTURE;
        let DO_SMART_CAPTURE_FACE = !!Credential.DO_SMART_CAPTURE_FACE;
        let DO_UNCROPPED = !!Credential.DO_UNCROPPED;
        let SERVER_CROPPING = DO_UNCROPPED || DO_SMART_CAPTURE;
        let MODE = Credential.MODE;
        let REPORT_IS_SENSITIVE = Credential.REPORT_IS_SENSITIVE;
        let REPORT_CONSOLE_LOGS = Credential.REPORT_CONSOLE_LOGS;
        let DO_IAD = Credential.DO_IAD;

        //Variables
        let report = { sensitive: {}, sdkLogs : [] };
        let lastPortrait = null;
        let lastFullName = null;

        //-----------------------------
        //------------ END ------------
        //-----------------------------

        //---------------------------------------------------------------------
        //------------ INITIALIZATION ------------
        //---------------------------------------------------------------------
        const rootUrl = window.location.href.substring(
            0,
            window.location.href.lastIndexOf("/") + 1
        );

        //Define ThalesThinLib built-in UIs
        const fontSizePercentage = 0.02;
        const fillRootColor = "rgb(111, 111, 111)";
        const UiMessages = {};
        UiMessages[ThalesThinLib.ENUM.ERROR_CROP] =
            "Ensure all corners are visible";
        UiMessages[ThalesThinLib.ENUM.UPLOADING] = "Uploading...";
        UiMessages["PROCESSING"] = "Analyzing...";
        UiMessages[ThalesThinLib.ENUM.HIGH_GLARE] = "Glare detected";
        UiMessages[ThalesThinLib.ENUM.LOW_RES] = "Come closer to document";
        UiMessages[ThalesThinLib.ENUM.LOW_SHARPNESS] = "Seems a bit blurry";
        UiMessages["ERROR_CLASSIFY"] = "Failed to analyze image";
        UiMessages[ThalesThinLib.ENUM.CAPTURE_BACK] = "FLIP document";
        UiMessages[ThalesThinLib.ENUM.ERROR_TIMEOUT] = "Timed out";
        UiMessages[ThalesThinLib.ENUM.ERROR_SDK] = "Timed out";
        UiMessages[ThalesThinLib.ENUM.ERROR_CLOSE_BTN] = "Let's try again";
        UiMessages[ThalesThinLib.ENUM.SDK_ERROR] = "Let's try again";
        UiMessages[ThalesThinLib.ENUM.SDK_FAILED] = "Let's try again";
        UiMessages[ThalesThinLib.ENUM.CAMERA_PERMISSIONS_DENIED] =
            "Allow Camera Permissions";
        UiMessages[ThalesThinLib.ENUM.CAMERA_PARAMS_ERR] =
            "Failed to start camera";
        UiMessages[ThalesThinLib.ENUM.CAMERA_ISSUE] = "Failed to start camera";
        UiMessages["REPOSITION"] = "Move the document a bit";
        UiMessages["RETRY_FRONT"] = "Try capturing again the FRONT side";
        UiMessages["RETRY_BACK"] = "Try capturing again the BACK side";
        UiMessages["FACE_ERROR"] = "Move a bit, light is not flattering";
        UiMessages["FACE_ROTATED"] = "Head has an angle. Try again";
        UiMessages["FACE_FAR"] = "Too far. Try again";
        UiMessages["FACE_CLOSE"] = "Too close. Try again";
        UiMessages["FACE_MANY"] = "Multiple faces detected. Try again>";
        UiMessages["VERIFICATION"] = "Verifying...";
        UiMessages["VERIFICATION_RETRY"] =
            "Plese try again. Capture FRONT side image...";
        UiMessages["VERIFY_AGAIN"] = "Couldn't verify document. Retry";
        UiMessages["INITIALIZE"] = "Initializing...";
        UiMessages[ThalesThinLib.ENUM.BROWSER_NOT_SUPPORTED] =
            "Browser is not supported, please use a different browser";

        const textSize = "20px";
        let UiRetake = {
            fillRootColor: fillRootColor,
            actionButtonText: "RETRY",
            textSize: textSize,
            fontSizePercentage: fontSizePercentage,
        };

        let UiRetakeImage = {
            fillRootColor: fillRootColor,
            actionButtonText: "RETRY",
            textSize: textSize,
            fontSizePercentage: fontSizePercentage,
            imageSrc: "./images/background.png",
            fillImage: true,
        };

        let UiUploadFront = {
            fillRootColor: fillRootColor,
            actionButtonText: "RETRY FRONT",
            textSize: textSize,
            //imageSrc: "./images/id.png",
            fontSizePercentage: fontSizePercentage,
        };

        let UiUploadBack = {
            fillRootColor: fillRootColor,
            actionButtonText: "RETRY BACK",
            textSize: textSize,
            //imageSrc: "./images/id_back.png",
            fontSizePercentage: fontSizePercentage,
        };

        let UiNoBtn = {
            fillRootColor: fillRootColor,
            actionButtonText: null, //Will only display
            textSize: textSize,
            imageSrc: "./images/background.png",
            fillImage: true,
            fontSizePercentage: fontSizePercentage,
        };

        let UiFlip = {
            fillRootColor: fillRootColor,
            actionButtonText: "DONE",
            textSize: textSize,
            imageSrc: "./images/id_flip.gif",
            fontSizePercentage: fontSizePercentage,
        };

        let UiReposition = {
            fillRootColor: fillRootColor,
            actionButtonText: "DONE",
            textSize: textSize,
            fontSizePercentage: fontSizePercentage,
            imageSrc: "./images/id_move.gif",
        };

        let UiBtn = {
            fillRootColor: fillRootColor,
            actionButtonText: "DONE",
            textSize: textSize,
            imageSrc: "./images/background.png",
            fillImage: true,
        };

        let UiPhotoSelect = {
            fillRootColor: fillRootColor,
            actionButtonText: "Approve",
            actionButtonAltText: "REJECT",
            textSize: textSize,
            fontSizePercentage: fontSizePercentage,
            //isPhoto: true,
        };

        showWait();

        //This could be downloaded from the backend
        const ThalesThinLibConfig = {
            ui: {
                text: {
                    NONE: "ALIGN",
                    SMALL_DOCUMENT: "MOVE CLOSER",
                    GOOD_DOCUMENT: null, //null=countdown
                    BIG_DOCUMENT: "TOO CLOSE",
                    CAPTURING: "HOLD STILL",
                    TAP_TO_CAPTURE: "TAP TO CAPTURE",
                },
                moveCloserHint: {
                    title: "Move Closer",                    
                    description: "Fit the document fully within the frame",
                },
                fixBlurHint: {                    
                    title: "Hold Steady",
                    description: "Hold the device steady",
                },
                fixGlareHint: {                    
                    title: "Glade detected",
                    description: "Reposition a bit the document",
                },
                outOfFrameHint: {                    
                    title: "No Document",
                    description: "Ensure all corners are within the frame",
                },
                capturingHint: {                    
                    title: "",
                    description: "Capturing...",
                },
                generalInfoTexts: {
                    front: "Position the FRONT of your document within the frame",
                    back: "Position the BACK of your document within the frame",
                    fallbackFront:
                        "Position the FRONT of your document within the frame and press the Button",
                    fallbackBack:
                        "Position the BACK of your document within the frame and press the Button",
                },
                autoCaptureText: "Auto Capture",
                alertText: "Not Working? Disable Auto Capture",
                faceNotFoundHint: "Position face in frame",
                probabilityTooSmallHint: "Position face in frame",
                tooManyFacesHint: "Multiple faces",
                faceAngleTooLargeHint: "Look straight",
                faceTooSmallHint: "Move closer",
                faceCloseToBorderHint: "Move further away",
                showHelpIcon: false,
                successTime: 500,
            },
            uncropped: DO_UNCROPPED,
            fillRootColor: "rgb(255, 255, 255)", //fill the background with this color
            captureTimeout: CAPTURE_TIMEOUT, //Capture timeout in milliseconds
            maxSdkAttempts: MAX_SDK_ATTEMPTS, //Maximum attempts to re-capture an image            
            maxCaptureAttempts: MAX_SERVER_ATTEMPTS, //Maximum uploaded images
            maxCaptureFaceAttempts: MAX_SERVER_ATTEMPTS, //Maximum uploaded images
            maxVerifAttempts: MAX_VERIF_ATTEMPTS, //Maximum uploaded images            
            actionButton: {
                text: "CLOSE",
                top: "6vw",
                top: "2vh",
                textSize: "20px",
                textColor: "white",
            },
            thresholds: {
                //If ommitted, default 450/50/50
                dpi: DPI_THRESH, //For Web Cams, it can be set low to allow errors to be caught differently
                glare: GLARE_THRESH,
                sharpness: SHARPNESS_THRESH,
            },      
            autoDetectConfig: {
                disableToggle: false, //disable auto capture toggle
                showToggleTimeout: 15 * 1000, //show auto capture toggle after some time
                disableToggleTimeout: null, //delay to enable toggle, use if showToggleTimeout not used
                maxExpTime: 3 * 1000, //what is considered too slow detection
                maxAllowedTooLong: null, //max times detection was too slow                
            },
            init: {
                onlyDocument: MODE !== "FACE_AND_DOC" && MODE !== "FACE_ONLY",
                onlyFace: MODE === "FACE_ONLY",
                jpegQuality: JPEG_QUALITY,
                debugBorders: false,
                smartCaptureDocument: DO_SMART_CAPTURE,
                smartCaptureFace: DO_SMART_CAPTURE_FACE,
                channel: "Test_AnyDocument",
                //Smart Capture ONLY                
                //slowLoadTimeout: 5 * 1000, //ms to wait for loading and initializing libraries
                isDebug: DO_DEBUG,
                //Base SDK ONLY
                baseSdkPath: rootUrl + "webSdk/dist", //used to load all other .js and rest of "SDK files"
                basicAuth: btoa(SDK_USER + ":" + SDK_PASS),
                //jwt: token, //use alternatively
                endpoint: SDK_ENDPOINT,                
                maxRetries: 3,
                retryTimeout: 500,
                slowMode: false,
                fromCDN: false,
            },
        };


        //-----------------------------------------
        //------- TEST APP DOCUMENT CAPTURE -------
        //-----------------------------------------

        //Initialize SDK
        ThalesThinLib.withSdk.setLogger(document.getElementById("logger"));        
        ThalesThinLib.withSdk
            .init(ThalesThinLibConfig)
            .then(() => {
                console.log(ThalesThinLib.withSdk.getLog());
                report.sdkLogs.push(ThalesThinLib.withSdk.getLog());
                updateText("Verify a new Identity", "IDV Test Page");
                showStart();
            })
            .catch((code, description) => {
                console.log(ThalesThinLib.withSdk.getLog());
                report.sdkLogs.push(ThalesThinLib.withSdk.getLog());
                updateText("Refresh the page to try gain", "Initialization Failed");
                showNOKFatal();
            });

        //Start capture
        async function startCamera(isFace, faceAndDoc) {
            ThalesThinLibConfig.mode = isFace
                ? ThalesThinLib.ENUM.FACE
                : ThalesThinLib.ENUM.DOCUMENT;
            const state = ThalesThinLib.withSdk.getState();
            const isBack = state === ThalesThinLib.ENUM.STATE_BACK;
            const isDocDone = state === ThalesThinLib.ENUM.STATE_FRONT_BACK;
            try {
                if (SPECIAL_DOUBLE_VERIF && !isFace) {
                    //Special case to get high quality image (100% JPEG quality)
                    //and compare against a lower quality image
                    //TBD: needs to implement inside ThalesThinLib
                }
                //Start session with backend asynchroneously
                const startSession = null;
                if (!report.scenarioId && DO_VERIFICATION && MODE !== "FACE_ONLY") {
                    startUpploadDocument(SERVER_CROPPING, "Mobile").then(
                        (backendSes) => {
                            if (backendSes && backendSes.id) {
                                report.scenarioId = backendSes.id;
                                ThalesThinLib.withSdk.setLogData({
                                    key: ThalesThinLib.ENUM.BACKEND_SESSION,
                                    value: report.scenarioId,
                                });
                            }
                        }
                    );
                }
                //Show waiting screen
                await ThalesThinLib.withSdk.errorMessageUi(
                    UiMessages["INITIALIZE"],
                    UiNoBtn
                );
                console.log(ThalesThinLib.withSdk.getLog());                
                //Start SDK UI
                const r = await ThalesThinLib.withSdk.capture(ThalesThinLibConfig);
                //UI is shown, get logs to confirm
                console.log(ThalesThinLib.withSdk.getLog());
                //Wait for capture
                await r.process;
                await ThalesThinLib.withSdk.errorMessageUi(
                    UiMessages["PROCESSING"],
                    UiNoBtn
                );
                console.log(ThalesThinLib.withSdk.getLog());
                //Wait for SDK processing
                await r.final;
                //Image available to upload
                console.log(ThalesThinLib.withSdk.getLog());
                report.sdkLogs.push(ThalesThinLib.withSdk.getLog());
                await ThalesThinLib.withSdk.errorMessageUi(
                    UiMessages[ThalesThinLib.ENUM.UPLOADING],
                    UiNoBtn
                );
                //Wait for backend session to start
                await startSession;
                //Send image for upload
                if (isFace) {
                    await uploadFace(report);
                } else {
                    await uploadDocument(report);
                }
                console.log(ThalesThinLib.withSdk.getLog());
                //Check if more upload attempts available
                const noAttempts =
                    ThalesThinLib.withSdk.getCaptures().left <= 0;

                //UPLOAD LOGIC
                const uploadOk = isFace ? report.faceOk : report.ok;
                if (!DO_VERIFICATION) {
                    showResults(report);
                } else if (report.doBack && !noAttempts) {
                    ThalesThinLib.withSdk.switchSide();
                    console.log(ThalesThinLib.withSdk.getLog());
                    report.sdkLogs.push(ThalesThinLib.withSdk.getLog());
                    ThalesThinLib.withSdk
                        .errorMessageUi(
                            UiMessages[ThalesThinLib.ENUM.CAPTURE_BACK],
                            UiFlip
                        )
                        .then(() => {
                            startCamera(isFace, faceAndDoc);
                        });
                } else if (uploadOk || noAttempts) {
                    if (!isFace) {
                        ThalesThinLib.withSdk.errorMessageUi(
                            UiMessages["VERIFICATION"],
                            UiNoBtn
                        );
                        await getDocumentVerification(report);
                        //Pass key data to record retry of same document
                        ThalesThinLib.withSdk.bothSidesDone(                            
                            report.ok
                                ? ThalesThinLib.ENUM.VERIFICATION_ACCEPTED
                                : ThalesThinLib.ENUM.VERIFICATION_REJECTED
                        );
                        console.log(ThalesThinLib.withSdk.getLog());
                        report.sdkLogs.push(ThalesThinLib.withSdk.getLog());
                        const noVerifAttempts =
                            ThalesThinLib.withSdk.getVerifications().left <= 0;
                        if (!report.ok && !noVerifAttempts) {
                            //Start a new verification session
                            await ThalesThinLib.withSdk.errorMessageUi(
                                UiMessages["VERIFICATION_RETRY"],
                                UiRetakeImage
                            );
                            openCamera();
                            return;
                        }
                    } else {
                        ThalesThinLib.withSdk.faceDone(report.faceOk
                            ? ThalesThinLib.ENUM.VERIFICATION_ACCEPTED
                            : ThalesThinLib.ENUM.VERIFICATION_REJECTED)
                        console.log(ThalesThinLib.withSdk.getLog());
                        report.sdkLogs.push(ThalesThinLib.withSdk.getLog());
                    }                    
                    if (faceAndDoc && !isFace && report.ok) {
                        startCamera(true, faceAndDoc);
                    } else {
                        showResults(report, isFace);
                    }
                } else {
                    if (isFace) {
                        let errMsg = UiMessages["FACE_ERROR"];
                        if (report.faceError === "FaceAngleTooLarge") {
                            errMsg = UiMessages["FACE_ROTATED"];
                        } else if (report.faceError === "FaceTooSmall") {
                            errMsg = UiMessages["FACE_FAR"];
                        } else if (report.faceError === "FaceCropped") {
                            errMsg = UiMessages["FACE_CLOSE"];
                        } else if (report.faceError === "TooManyFaces") {
                            errMsg = UiMessages["FACE_MANY"];
                        } else if (
                            report.faceError &&
                            report.faceError.includes("Injected")
                        ) {
                            errMsg = "Are you for real? " + report.faceLiveScore;
                        } else if (
                            report.faceError &&
                            report.faceError.includes("NotLive")
                        ) {
                            errMsg = "Are you alive? " + report.faceLiveScore;
                        }
                        ThalesThinLib.withSdk
                            .errorMessageUi(errMsg, UiRetake)
                            .then(() => {
                                startCamera(isFace, faceAndDoc);
                            });
                    } else {
                        const sharp = report[isBack ? "backendSharpnessBack" : "backendSharpness"];
                        const glare = report[isBack ? "backendGlareBack" : "backendGlare"];
                        const dpi = report[isBack ? "backendDpiBack" : "backendDpi"];
                        const isCropped = report[isBack ? "backendCroppedBack" : "backendCropped"] ? "y" : "n";                        
                        let errMsg = UiMessages["ERROR_CLASSIFY"];
                        if (isCropped !== undefined || sharp !== undefined || glare !== undefined) {
                            errMsg += " (" +
                                (isCropped ? isCropped : "") +
                                (sharp ? "," + sharp : "") +
                                (glare ? "," + glare : "") +
                                (dpi ? "," + dpi : "") +
                                ")";
                        }
                        await ThalesThinLib.withSdk.errorMessageUi(
                            errMsg,
                            UiRetake
                        );
                        const frontBackLabel = !isBack ? "RETRY_FRONT" : "RETRY_BACK"
                        ThalesThinLib.withSdk
                            .errorMessageUi(UiMessages[frontBackLabel], UiReposition)
                            .then(() => {
                                startCamera(isFace, faceAndDoc);
                            });
                    }
                }
                //END
            } catch (code) {
                console.log("Capture failed: " + code);
                if (
                    code === ThalesThinLib.ENUM.LOW_RES ||
                    code === ThalesThinLib.ENUM.ERROR_CROP ||
                    code === ThalesThinLib.ENUM.LOW_SHARPNESS
                ) {
                    ThalesThinLib.withSdk
                        .errorMessageUi(UiMessages[code], UiRetake)
                        .then(() => {
                            startCamera(isFace, faceAndDoc);
                        });
                } else if (code === ThalesThinLib.ENUM.HIGH_GLARE) {
                    await ThalesThinLib.withSdk.errorMessageUi(
                        UiMessages[code],
                        UiRetake
                    );
                    ThalesThinLib.withSdk
                        .errorMessageUi(UiMessages["REPOSITION"], UiReposition)
                        .then(() => {
                            startCamera(isFace, faceAndDoc);
                        });
                } else {
                    //Some other error
                    const errMsg = UiMessages[code]
                        ? UiMessages[code]
                        : "Something went wrong";
                    ThalesThinLib.withSdk
                        .errorMessageUi(errMsg, UiRetakeImage)
                        .then(() => {
                            startCamera(isFace, faceAndDoc);
                        });
                }
            }
        }

        async function startCameraWithPermissions(isFace, faceAndDoc) {
            let perm = await ThalesThinLib.cameraUtils.checkPermissions();
            if (perm === ThalesThinLib.ENUM.CAMERA_PERMISSIONS_GRANTED) {
                startCamera(isFace, faceAndDoc);
            } else if (
                perm === ThalesThinLib.ENUM.CAMERA_PERMISSIONS_DENIED &&
                ThalesThinLib.utils.platform() !== ThalesThinLib.ENUM.IOS
            ) {
                //Android only supports user enablement form URL icons
                await ThalesThinLib.withSdk.errorMessageUi("Enable camera from URL bar", UiBtn);
                startCameraWithPermissions(isFace, faceAndDoc);
            } else {
                //Inform user that they will be prompted, only if explicitly that is the result
                if (perm === ThalesThinLib.ENUM.CAMERA_PERMISSIONS_PROMPT) {
                    await ThalesThinLib.withSdk.errorMessageUi("Please Accept permissions", UiBtn);
                }
                //The user needs to grant permissions or the query permission API wasn't supported
                //and we don't know the status
                perm = await ThalesThinLib.cameraUtils.getPermissions();
                if (perm === ThalesThinLib.ENUM.CAMERA_PERMISSIONS_GRANTED) {
                    startCamera(isFace, faceAndDoc);
                } else {
                    await ThalesThinLib.withSdk.errorMessageUi("Camera access is required!", UiBtn);
                }
            }
        }

        //Initiate capture
        function openCamera() {
            const isFace = MODE === "FACE_ONLY";
            const faceAndDoc = MODE === "FACE_AND_DOC";
            //Starts a new session
            ThalesThinLib.withSdk.newSession();
            startCameraWithPermissions(isFace, faceAndDoc);
            //Used to track results, not used by ThalesThinLib in any way
            report = { sensitive: {}, sdkLogs: [] };
        }

        //Display results
        function showResults(report) {
            try {
                ThalesThinLib.withSdk.errorMessageUi(null);
                let finalResult = "N/A";
                let finalAuth = "";
                let finalAuthTamper = "";
                let finalFaceAuth = "N/A";
                let finalFaceScore = "";
                let classification = "";
                let scenarioId = "";
                let capture = "";
                let connectTime = "N/A";
                let uploadTime = "";
                let uploadSize = "";
                let glare = "";
                let sharpness = "";
                let dpi = "";
                let docNumber = "";
                let fullName = "";
                lastFullName = "Client";
                let expirationDate = "";
                let dateOfBirth = "";
                let imageDocument = new Image();
                imageDocument.style.width = "100%";
                imageDocument.style.height = "100%";
                imageDocument.style.objectFit = "contain";
                imageDocument.alt = "No Image";
                let imageDocumentBack = new Image();
                imageDocumentBack.style.width = "100%";
                imageDocumentBack.style.height = "100%";
                imageDocumentBack.style.objectFit = "contain";
                imageDocumentBack.alt = "No Image";
                let imagePortrait = new Image();
                imagePortrait.style.width = "100%";
                imagePortrait.style.height = "100%";
                imagePortrait.style.objectFit = "contain";
                imagePortrait.alt = "No Image";
                let imagFace = new Image();
                imagFace.style.width = "100%";
                imagFace.style.height = "100%";
                imagFace.style.objectFit = "contain";
                imagFace.alt = "No Image";
                imagFace.style.maxHeight = "200px";
                let pdfLink = "N/A";
                let logLink3 = "N/A";
                let imgSettings = "N/A";
                let sdkErrors = "";
                let autoDetections = "";

                const log = ThalesThinLib.withSdk.getLog();                
                if (log) {
                    if (log.captureTime) {
                        capture +=
                            "Front: " +
                            (log.captureTime / 1000).toFixed(2) +
                            "secs";
                    }
                    if (log.captureTimeBack) {
                        capture +=
                            " / Back: " +
                            (log.captureTimeBack / 1000).toFixed(2) +
                            "secs";
                    }
                    if (log.captureTimeFace) {
                        capture +=
                            " / Face: " +
                            (log.captureTimeFace / 1000).toFixed(2) +
                            "secs";
                    }
                    const avgAutoDetect =
                        log.autoDetection && log.autoDetection.count > 0
                            ? (log.autoDetection.end - log.autoDetection.start) /
                            log.autoDetection.count
                            : null;
                    const avgAutoDetectBack =
                        log.autoDetectionBack && log.autoDetectionBack.count > 0
                            ? (log.autoDetectionBack.end - log.autoDetectionBack.start) /
                            log.autoDetectionBack.count
                            : null;
                    const maxTime = log.autoDetection ? log.autoDetection.maxTime : 0;
                    const maxTimeBack = log.autoDetectionBack
                        ? log.autoDetectionBack.maxTime
                        : 0;
                    const tooLong = log.autoDetection ? log.autoDetection.tooLong : 0;
                    const tooLongBack = log.autoDetectionBack
                        ? log.autoDetectionBack.tooLong
                        : 0;
                    autoDetections =
                        "Front: Avg: " +
                        (avgAutoDetect / 1000).toFixed(2) +
                        "s, Max:" +
                        (maxTime / 1000).toFixed(2) +
                        "s (" +
                        +tooLong +
                        ")";
                    if (avgAutoDetectBack) {
                        autoDetections +=
                            " / Back: Avg: " +
                            (avgAutoDetectBack / 1000).toFixed(2) +
                            "s, Max:" +
                            (maxTimeBack / 1000).toFixed(2) +
                            "s (" +
                            +tooLongBack +
                            ")";
                    }
                    if (MODE === "FACE_AND_DOC") {
                        sdkErrors = "Front: " + log.worstError +
                            ", Back: " + log.worstErrorBack +
                            ", Face: " + log.worstErrorFace;
                    } else if (MODE === "FACE_ONLY") {
                        sdkErrors = "Face: " + log.worstErrorFace;
                    } else {
                        sdkErrors = "Front: " + log.worstError +
                            ", Back: " + log.worstErrorBack;
                    }
                }
                const state = ThalesThinLib.withSdk.getState();
                const isBack = state === ThalesThinLib.ENUM.STATE_BACK;
                const isDocDone = state === ThalesThinLib.ENUM.STATE_FRONT_BACK;
                const sdkError = isBack ? log.worstErrorBack : log.worstError;                

                const docOK = report.ok || report.ok === undefined ? "OK" : sdkError;
                const faceOk =
                    report.faceOk || report.faceOk === undefined
                        ? "OK"
                        : report.faceError;
                finalResult =
                    docOK === "OK" && faceOk === "OK"
                        ? "OK"
                        : faceOk !== "OK" && docOK !== "OK"
                            ? docOK + " / " + faceOk
                            : docOK === "OK" && faceOk !== "OK"
                                ? faceOk
                                : isDocDone
                                    ? "Verification Failed"
                                    : "Capture/Upload Failed";
                finalAuth = report.result || "";
                finalAuthTamper = report.tamperRes || "";
                finalFaceAuth = report.faceError;
                finalFaceScore = report.faceLiveScore + " , Match: " + report.faceMatchScore;
                classification = report.classification || "";
                if (log && log.isUncropped) {
                    classification += " [server crop]";
                }
                scenarioId = report.scenarioId || "";
                docNumber = report.docNumber || "";
                fullName = report.fullName || "";
                lastFullName = !!fullName ? fullName : lastFullName;
                expirationDate = report.expirationDate || "";
                dateOfBirth = report.dateOfBirth || "";
                uploadTime = "Upload Front: " + report.uploadTime;
                if (report.uploadTimeBack) {
                    uploadTime += " / Back: " + report.uploadTimeBack;
                }
                if (report.uploadTimeFace) {
                    uploadTime += " / Face: " + report.uploadTimeFace;
                }
                uploadSize = "Size Front: " + report.uploadSize;
                if (report.uploadSizeBack) {
                    uploadSize += " / Back: " + report.uploadSizeBack;
                }
                if (report.uploadSizeFace) {
                    uploadSize += " / Face: " + report.uploadSizeFace;
                }
                const fImg = ThalesThinLib.withSdk.getImage("FRONT");
                const bImg = ThalesThinLib.withSdk.getImage("BACK");
                const faceImg =
                    MODE !== "FACE_ONLY" && MODE !== "FACE_AND_DOC"
                        ? null
                        : ThalesThinLib.withSdk.getImage("FACE");
                const fDetails = log.captureDetails
                const bDetails = log.captureDetailsBack;
                if (fImg) {
                    imageDocument.src = "data:image/jpeg;base64," + fImg || "";
                    sharpness =
                        fDetails && !DO_SMART_CAPTURE
                            ? fDetails.sharpness
                            : report.backendSharpness
                                ? report.backendSharpness
                                : "N/A";
                    glare =
                        fDetails && !DO_SMART_CAPTURE
                            ? fDetails.glare
                            : report.backendGlare
                                ? report.backendGlare
                                : "N/A";
                    dpi =
                        fDetails && !DO_SMART_CAPTURE
                            ? fDetails.dpi
                            : report.backendDpi
                                ? report.backendDpi
                                : "N/A";
                    if (bImg) {
                        imageDocumentBack.src = "data:image/jpeg;base64," + bImg || "";
                        sharpness +=
                            bDetails && !DO_SMART_CAPTURE
                                ? " / " + bDetails.sharpness
                                : report.backendSharpnessBack
                                    ? " / " + report.backendSharpnessBack
                                    : "";
                        glare +=
                            bDetails && !DO_SMART_CAPTURE
                                ? " / " + bDetails.glare
                                : report.backendGlareBack
                                    ? " / " + report.backendGlareBack
                                    : "";
                        dpi +=
                            bDetails && !DO_SMART_CAPTURE
                                ? " / " + bDetails.dpi
                                : report.backendDpiBack
                                    ? " / " + report.backendDpiBack
                                    : "";
                    }
                }
                if (faceImg) {
                    imagFace.src = "data:image/jpeg;base64," + faceImg || "";
                }
                if (report && report.portrait) {
                    imagePortrait.src = "data:image/jpeg;base64," + report.portrait;
                    lastPortrait = report.portrait;
                }

                if (log) {
                    const content = JSON.stringify(log, null, 2);
                    const blob = new Blob([content], { type: content });
                    logLink3 = document.createElement("a");
                    const href = URL.createObjectURL(blob);
                    const filename =
                        "ThalesThinLibSession_" +
                        new Date().toLocaleTimeString() +
                        ".json";
                    logLink3.setAttribute("href", href);
                    logLink3.setAttribute("download", filename);
                    logLink3.innerHTML = "Session Logs";
                }
                if (report.pdf) {
                    const content = ThalesThinLib.utils.decodeBase64(report.pdf);
                    const blob = new Blob([content], { type: "application/pdf" });
                    pdfLink = document.createElement("a");
                    const href = URL.createObjectURL(blob);
                    const filename = "IDV_" + new Date().toLocaleTimeString() + ".pdf";
                    pdfLink.setAttribute("href", href);
                    pdfLink.setAttribute("download", filename);
                    pdfLink.innerHTML = "Verification Report";
                }

                const tables = [];
                //Final Report to be downloaded
                const downReport = JSON.parse(JSON.stringify(report));
                downReport.doBack = undefined; //remove some unecessary data
                downReport.pdf = undefined;
                downReport.docNumber = undefined;
                downReport.fullName = undefined;
                downReport.expirationDate = undefined;
                downReport.dateOfBirth = undefined;
                if (REPORT_IS_SENSITIVE) {
                    downReport.sensitive.frontWhiteImage = fImg;
                    downReport.sensitive.backWhiteIMage = bImg;
                    downReport.sensitive.faceImage = faceImg;
                } else {
                    downReport.sensitive.fields = undefined;
                }
                if (REPORT_CONSOLE_LOGS) {
                    downReport.consoleLogs = document.getElementById("logger").value;
                }
                const jBlob = new Blob([JSON.stringify(downReport)], {
                    type: "application/json",
                });
                const fLink = document.createElement("a");
                fLink.setAttribute("href", URL.createObjectURL(jBlob));
                fLink.setAttribute(
                    "download",
                    "Deltaresults_" + new Date().toLocaleTimeString() + ".json"
                );
                fLink.innerHTML = "Report";
                tables.push({
                    header: ["Report"],
                    rows: [{ cols: [fLink] }],
                });

                //Final table built
                tables.push({
                    header: ["Document Authentication"],
                    rows: [
                        {
                            cols: ["Result", finalResult],
                        },
                        {
                            cols: ["Base Document Authentication", finalAuth],
                        },
                        {
                            cols: ["Document Tampering Detection", finalAuthTamper],
                        },
                        {
                            cols: ["Document Classification", classification],
                        },
                        {
                            cols: ["Face Verification", finalFaceAuth],
                        },
                        {
                            cols: ["Face Verification Scores", finalFaceScore],
                        },
                        {
                            cols: ["SDK Errors", sdkErrors],
                        },
                        {
                            cols: ["IdCloud Session ID", scenarioId,],
                        },
                        {
                            cols: ["Upload Time", uploadTime],
                        },
                        {
                            cols: ["Auto Detection", autoDetections],
                        },
                        {
                            cols: ["Image Size", uploadSize],
                        },
                        {
                            cols: ["Sharpness (Front / Back)", sharpness],
                        },
                        {
                            cols: ["Glare (Front / Back)", glare],
                        },
                        {
                            cols: ["Resolution/DPI (Front / Back)", dpi],
                        },
                        {
                            cols: ["Image Capture", capture],
                        },
                        {
                            cols: log.checkColor
                                ? ["Check Color", JSON.stringify(log.checkColor, null, 2)]
                                : undefined,
                        },
                    ],
                });
                tables.push({
                    header: ["Data Extraction"],
                    rows: [
                        {
                            cols: ["Full Name", fullName],
                        },
                        {
                            cols: ["Date of Birth", dateOfBirth],
                        },
                        {
                            cols: ["Document Number", docNumber],
                        },
                        {
                            cols: ["Expiration Date", expirationDate],
                        },
                    ],
                });
                tables.push({
                    header: ["Images"],
                    rows: [
                        {
                            cols: ["Front-side", imageDocument],
                        },
                        {
                            cols: ["Back-side", imageDocumentBack],
                        },
                        {
                            cols: ["Selfie", imagFace],
                        },
                        {
                            cols: ["Document Photo", imagePortrait],
                        },
                    ],
                });
                tables.push({
                    header: ["Logs and Reports"],
                    rows: [
                        {
                            cols: ["PDF Verification Report", pdfLink],
                        },
                        {
                            cols: ["Session Logs", logLink3],
                        },
                    ],
                });
                tables.push({
                    header: ["Security Tests"],
                    rows: report && report.alerts ? report.alerts : null,
                });
                tables.push({
                    header: ["All Extracted Data"],
                    rows:
                        report && report.sensitive && report.sensitive.fields
                            ? report.sensitive.fields
                            : null,
                });

                makeTable(tables, document.getElementById("restable"));
                if (!DO_VERIFICATION) {
                    updateText("Images captured");
                    showOK();
                } else if (report.ok !== false && report.faceOk !== false) {
                    updateText(
                        lastFullName + " has been verified!",
                        "Verification Completed"
                    );
                    showOK();
                } else {
                    updateText(
                        "The person's identity couldn't be verified. Try again!",
                        "Failed"
                    );
                    showNOK();
                }
            } catch (e) {
                alert("Demo Error: populating results screen.");
                console.log("showResults: " + e);
            }
        }

        //-----------------------------
        //------------ END ------------
        //-----------------------------

        //-----------------------------------------
        //----------- WEB API FUNCTIONS -----------
        //-----------------------------------------
        //Thales IdCloud functions
        async function startUpploadDocument(cropping, mode) {
            return new Promise(async (resolve, reject) => {
                console.log("Staring upload session...");
                const idcUrl =
                    "https://fake-bank-demo.rnd.gemaltodigitalbankingidcloud.com";
                const idcScenario =
                    MODE === "FACE_AND_DOC"
                        ? "Connect_Verify_Document_Face_Passive_Liveness"
                        : "Connect_Verify_Document";
                const version = DO_SMART_CAPTURE_FACE && MODE == "FACE_AND_DOC" && DO_IAD ? 3 : 2;
                const id = await idcPost(
                    idcUrl,
                    Credential.USER_PROXY,
                    Credential.PASS_PROXY,
                    idcScenario,
                    version,
                    null,
                    {
                        captureMethod: mode,
                        croppingMode: cropping ? "Always" : "None",
                    }
                );
                //resolve(id + "#" + token);
                resolve(id);
            });
        }

        function uploadDocument(report, options) {
            const idcUrl =
                "https://fake-bank-demo.rnd.gemaltodigitalbankingidcloud.com";
            const idcScenario =
                MODE === "FACE_AND_DOC"
                    ? "Connect_Verify_Document_Face_Passive_Liveness"
                    : "Connect_Verify_Document";
            const isUv = options && options.isUv;
            const isIr = options && options.isIr;
            return new Promise(async (resolve, reject) => {
                const isBack =
                    ThalesThinLib.withSdk.getState() ===
                    ThalesThinLib.ENUM.STATE_BACK;
                if (!DO_VERIFICATION) {
                    report.ok = true;
                    report.doBack = !isBack;
                    report.result = "Skipped";
                    resolve(report);
                    return;
                }
                if (!report.scenarioId) {
                    report.ok = false;
                    report.doBack = !isBack;
                    report.result = "No Session";
                    resolve(report);
                    return;
                }
                //Get image, taking into account the scenario it can be a UV or IM images
                const light = isUv ? "UV" : isIr ? "IR" : "White";
                const side = !isBack ? "front" : "back";
                //SUPPORT FOR IR/UV TBD
                const image =
                    options && options.image
                        ? options.image
                        : ThalesThinLib.withSdk.getImage(side);
                if (!image) {
                    //skip
                    resolve(report);
                    return;
                }
                console.log("Uploading...");
                let start = Date.now();
                let sideParam = isBack ? "backWhiteImage" : "frontWhiteImage";
                let sideReport = isBack ? "uploadTimeBack" : "uploadTime";
                let sideReportSize = isBack ? "uploadSizeBack" : "uploadSize";
                if (isUv) {
                    sideParam = isBack ? "backUVImage" : "frontUVImage";
                    sideReport = isBack ? "uploadTimeUVBack" : "uploadTimeUV";
                    sideReportSize = isBack ? "uploadSizeUVBack" : "uploadSizeUV";
                } else if (isIr) {
                    sideParam = isBack ? "backIRImage" : "frontIRImage";
                    sideReport = isBack ? "uploadTimeIRBack" : "uploadTimeIR";
                    sideReportSize = isBack ? "uploadSizeIRBack" : "uploadSizeIR";
                }
                let input = {};
                input[sideParam] = image;
                let res = await idcPatch(
                    report.scenarioId,
                    idcUrl,
                    Credential.USER_PROXY,
                    Credential.PASS_PROXY,
                    idcScenario,
                    sideParam,
                    input
                );
                let elapsed = Date.now() - start;
                console.log("Upload time: " + (elapsed / 1000).toFixed(2) + " sec");
                report[sideReport] = (elapsed / 1000).toFixed(2) + " sec";
                report[sideReportSize] =
                    ((image.length * (2 / 3)) / 1024).toFixed(2) + " kb";
                //Consider UV/IR optional, in the context of edge case scenarios that uplaod fails
                if (isUv || isIr) {
                    //do nothing, let white image decide results
                    resolve(report);
                    return;
                }
                try {
                    report.ok =
                        !!res.state.result.object[sideParam] &&
                        !res.state.result.object[sideParam].IsGeneric;
                    report.classification = res.state.result.object.classification.Name;
                    const metrics = res.state.result.object.metrics;
                    if (metrics) {
                        report[isBack ? "backendDpiBack" : "backendDpi"] = Math.min(
                            metrics.HorizontalResolution,
                            metrics.VerticalResolution
                        );
                        report[isBack ? "backendGlareBack" : "backendGlare"] =
                            metrics.GlareMetric;
                        report[isBack ? "backendSharpnessBack" : "backendSharpness"] =
                            metrics.SharpnessMetric;
                        report[isBack ? "backendCroppedBack" : "backendCropped"] = metrics.IsCropped;
                    }
                    let supSides =
                        res.state.result.object.classification.SupportedImages;
                    let backSupported = false;
                    for (let sl in supSides) {
                        if (supSides[sl].Light === 0 && supSides[sl].Side === 1) {
                            backSupported = true;
                            break;
                        }
                    }
                    console.log("Back is supported: " + backSupported);
                    report.doBack = backSupported && !isBack && report.ok;
                    if (!report.ok) {
                        console.log("Classification failed");
                        resolve(report);
                        return;
                    }
                    console.log("Document is classified!");
                } catch (e) {
                    console.log("Classification response exception: " + e);
                    report.ok = false;
                    report.result = "API_ERROR";
                    alert(
                        "Temporarily DEMO backend error. You may have to refresh the page"
                    );
                }
                resolve(report);
            });
        }

        function getDocumentVerification(report) {
            const idcUrl =
                "https://fake-bank-demo.rnd.gemaltodigitalbankingidcloud.com";
            const idcScenario =
                MODE === "FACE_AND_DOC"
                    ? "Connect_Verify_Document_Face_Passive_Liveness"
                    : "Connect_Verify_Document";
            return new Promise(async (resolve) => {
                if (!report.scenarioId) {
                    console.log("No active session");
                    resolve();
                    return;
                }
                console.log("Getting results...");
                const res = await idcPatch(
                    report.scenarioId,
                    idcUrl,
                    Credential.USER_PROXY,
                    Credential.PASS_PROXY,
                    idcScenario,
                    "verifyResults"
                );
                try {
                    let authRes =
                        res.state.result.object.document.verificationResults.result;
                    const alerts =
                        res.state.result.object.document.verificationResults.alerts;
                    const regions =
                        res.state.result.object.document.verificationResults.regions;
                    let tamperRes = true;
                    if (alerts) {
                        report.alerts = [];
                        for (let i = 0; i < alerts.length; ++i) {
                            let name = alerts[i].Key;
                            if (alerts[i].Model) {
                                name += "-" + alerts[i].Model;
                            } else if (
                                alerts[i].RegionReferences &&
                                alerts[i].RegionReferences.length === 1
                            ) {
                                for (let j = 0; j < regions.length; ++j) {
                                    if (alerts[i].RegionReferences[0] === regions[j].Id) {
                                        name += "-" + regions[j].Key;
                                        break;
                                    }
                                }
                            }
                            let value = alerts[i].Result;
                            if (value == 1) {
                                value = "Passed";
                            } else if (value == 2) {
                                value = "Failed";
                            } else if (value == 4) {
                                value = "Caution";
                            } else if (value == 5) {
                                value = "Attention";
                            } else {
                                value = "Unknown";
                            }
                            report.alerts.push({ cols: [name, value] });
                            if (authRes !== "Attention" || value != "Attention") continue;
                            if (name === "Document Classification") {
                                authRes += "Class";
                            } else if (name === "Document Expired") {
                                authRes += "Expired";
                            } else if (name === "2D Barcode Read") {
                                authRes += "Barcode";
                            }
                            //Check digital tampering
                            if (value === "Failed") {
                                if (
                                    name ==
                                    "Document Tampering Detection-Enhanced Portrait Substitution Detection" ||
                                    name ==
                                    "Document Tampering Detection-Physical Document Presence V5.1" ||
                                    name ==
                                    "Document Tampering Detection-Text Tampering Detection V1.2.1"
                                ) {
                                } else {
                                    tamperRes = false;
                                }
                            }
                        }
                    }
                    const fields =
                        res.state.result.object.document.verificationResults.dataFields;
                    if (fields) {
                        report.sensitive.fields = [];
                        for (let i = 0; i < fields.length; ++i) {
                            let name = fields[i].Key;
                            let type = fields[i].Type;
                            let value = fields[i].Value;
                            if (type === "uri") continue;
                            if (type === "datetime") {
                                try {
                                    value = new Date(
                                        value.replace("/Date(", "").replace(")/", "")
                                    );
                                } catch { }
                            }
                            report.sensitive.fields.push({ cols: [name, value] });
                        }
                    }
                    report.ok =
                        tamperRes &&
                        (authRes === "Passed" ||
                            authRes === "AttentionBarcode" ||
                            authRes === "AttentionExpired"); //normally expired documents wouldn't be allowed but useful for testing
                    report.result = authRes;
                    report.tamperRes = tamperRes ? "Passed" : "Failed";
                    report.docNumber =
                        res.state.result.object.document.verificationResults.documentNumber;
                    report.fullName =
                        res.state.result.object.document.verificationResults.firstName +
                        " " +
                        res.state.result.object.document.verificationResults.surname;
                    report.dateOfBirth =
                        res.state.result.object.document.verificationResults.birthDate;
                    report.expirationDate =
                        res.state.result.object.document.verificationResults.expirationDate;
                    report.portrait = res.state.result.object.document.portrait;
                    report.pdf = res.state.result.object.document.resultsPDF;
                } catch (e) {
                    console.log("Verification response exception: " + e);
                    report.ok = false;
                    report.result = "API_ERROR";
                    alert(
                        "Temporarily DEMO backend error. You may have to refresh the page"
                    );
                }
                const intSession = ThalesThinLib.withSdk.getInternalSession();
                if (
                    SPECIAL_DOUBLE_VERIF &&
                    intSession &&
                    intSession.internal.bestResult.image &&
                    intSession.internal.bestResultBack &&
                    intSession.internal.bestResultBack.image
                ) {
                    console.log("Posting hi quality images...");
                    const idcUrl =
                        "https://fake-bank-demo.rnd.gemaltodigitalbankingidcloud.com";
                    const idcScenario =
                        MODE === "FACE_AND_DOC"
                            ? "Connect_Verify_Document_Face_Passive_Liveness"
                            : "Connect_Verify_Document";
                    const version = 2;
                    const res1 = await idcPost(
                        idcUrl,
                        Credential.USER_PROXY,
                        Credential.PASS_PROXY,
                        idcScenario,
                        version,
                        null,
                        {
                            captureMethod: "Mobile",
                            croppingMode: "None",
                            frontWhiteImage:
                                intSession.internal.bestResult.image.hiQualImage.split(
                                    ","
                                )[1],
                            backWhiteImage:
                                intSession.internal.bestResultBack.image.hiQualImage.split(
                                    ","
                                )[1],
                        }
                    );
                    if (res1 && res1.id) {
                        console.log("Getting second results...");
                        const res2 = await idcPatch(
                            res1.id,
                            idcUrl,
                            Credential.USER_PROXY,
                            Credential.PASS_PROXY,
                            idcScenario,
                            "verifyResults"
                        );

                        let authRes2 =
                            res2.state.result.object.document.verificationResults.result;
                        let tamperRes2 =
                            res2.state.result.object.document.verificationResults
                                .tamperResult;
                        const alerts2 =
                            res2.state.result.object.document.verificationResults.alerts;
                        const regions2 =
                            res2.state.result.object.document.verificationResults.regions;
                        report.SPECIAL_DOUBLE_VERIF = {};
                        report.SPECIAL_DOUBLE_VERIF.alerts = [];
                        if (alerts2) {
                            for (let i = 0; i < alerts2.length; ++i) {
                                let name = alerts2[i].Key;
                                if (alerts2[i].Model) {
                                    name += "-" + alerts2[i].Model;
                                } else if (
                                    alerts2[i].RegionReferences &&
                                    alerts2[i].RegionReferences.length === 1
                                ) {
                                    for (let j = 0; j < regions2.length; ++j) {
                                        if (alerts2[i].RegionReferences[0] === regions2[j].Id) {
                                            name += "-" + regions2[j].Key;
                                            break;
                                        }
                                    }
                                }
                                let value = alerts2[i].Result;
                                if (value == 1) {
                                    value = "Passed";
                                } else if (value == 2) {
                                    value = "Failed";
                                } else if (value == 4) {
                                    value = "Caution";
                                } else if (value == 5) {
                                    value = "Attention";
                                } else {
                                    value = "Unknown";
                                }
                                if (report.alerts) {
                                    for (let pa = 0; pa < report.alerts.length; ++pa) {
                                        const pName = report.alerts[pa].cols[0];
                                        if (pName === name) {
                                            const pValue = report.alerts[pa].cols[1];
                                            if (pValue !== value) {
                                                report.SPECIAL_DOUBLE_VERIF.alerts.push({
                                                    cols: ["Delta " + name, value, pValue],
                                                });
                                                console.log(
                                                    "SPECIAL CHECK-> " +
                                                    pName +
                                                    "=" +
                                                    pValue +
                                                    "-" +
                                                    value
                                                );
                                            }
                                        }
                                    }
                                }
                                if (authRes2 !== "Attention" || value != "Attention")
                                    continue;
                                if (name === "2D Barcode Read") {
                                    authRes2 += " (2D Barcode not read)";
                                } else if (name === "Document Expired") {
                                    authRes2 += " (EXPIRED)";
                                } else if (name === "Document Classification") {
                                    authRes2 += " (Backside not classified)";
                                }
                            }
                        }
                        console.log(
                            "SPECIAL CHECK-> Result=" + report.result + " vs " + authRes2
                        );
                        console.log(
                            "SPECIAL CHECK-> TamperResult=" +
                            report.tamperRes +
                            " vs " +
                            tamperRes2
                        );
                        report.SPECIAL_DOUBLE_VERIF.result = authRes2;
                        report.SPECIAL_DOUBLE_VERIF.tamperRes = tamperRes2;
                    }
                }
                resolve();
            });
        }

        async function uploadFace(report) {
            console.log("Uploading...");
            report.doBack = false;
            const idcUrl =
                "https://fake-bank-demo.rnd.gemaltodigitalbankingidcloud.com";
            const idcScenario =
                MODE == "FACE_AND_DOC"
                    ? "Connect_Verify_Document_Face_Passive_Liveness"
                    : "Connect_Face_Match_Passive_Liveness";
            const encryptedFile = DO_SMART_CAPTURE_FACE && DO_IAD;
            const version = encryptedFile
                ? 3
                : MODE == "FACE_AND_DOC"
                    ? 2
                    : 1;
            return new Promise(async (resolve, reject) => {
                if (!DO_VERIFICATION) {
                    report.faceOk = true;
                    report.faceError = "Skipped";
                    resolve(report);
                    return;
                }
                
                const selfie = ThalesThinLib.withSdk.getImage("FACE", encryptedFile);
                const clearSelfie = ThalesThinLib.withSdk.getImage("FACE", false);
                const photo = lastPortrait || clearSelfie;
                if (!selfie) {
                    //skip
                    report.faceOk = false;
                    report.faceError = "NO_FACE";
                    console.log("Face Verification: No image");
                    resolve(report);
                    return;
                }
                let startTime = Date.now();
                
                const start =
                    MODE === "FACE_AND_DOC"
                        ? await idcPatch(
                            report.scenarioId,
                            idcUrl,
                            Credential.USER_PROXY,
                            Credential.PASS_PROXY,
                            idcScenario,
                            "faceMatch",
                            {
                                face: selfie,
                            }
                        )
                        : await idcPost(
                            idcUrl,
                            Credential.USER_PROXY,
                            Credential.PASS_PROXY,
                            idcScenario,
                            version,
                            null,
                            {
                                face: photo,
                                passiveLiveness: selfie,
                            }
                        );
                if (!start || !start.id) {
                    report.faceOk = false;
                    report.faceError = "API_ERROR";
                    alert(
                        "Temporarily DEMO backend error. You may have to refresh the page"
                    );
                    console.log("Face Verification: " + JSON.stringify(start, null, 2));
                    resolve(report);
                    return;
                }
                //Face verification with polling
                const delay = 2000;
                let res = null;
                for (let rr = 0; rr < 3; ++rr) {
                    console.log("Polling verification results...");
                    res = await idcGetStatus(
                        start.id,
                        idcUrl,
                        Credential.USER_PROXY,
                        Credential.PASS_PROXY
                    );
                    console.log("Polled verification results");
                    if (!res) {
                        report.faceOk = false;
                        report.faceError = "API_ERROR";
                        alert(
                            "Temporarily DEMO backend error. You may have to refresh the page"
                        );
                        console.log("Face Verification: " + JSON.stringify(res, null, 2));
                        resolve(report);
                        return;
                    }
                    if (!res.state.result) {
                        console.log("Delaying 2 secs to poll verification results...");
                        await new Promise((res) => {
                            window.setTimeout(() => {
                                res();
                            }, delay);
                        });
                    }
                }
                report.uploadSizeFace =
                    ((selfie.length * (2 / 3)) / 1024).toFixed(2) + " kb";
                let elapsed = Date.now() - startTime;
                console.log("Upload time: " + (elapsed / 1000).toFixed(2) + " sec");
                report.uploadTimeFace = (elapsed / 1000).toFixed(2) + " sec";

                if (!res.state.result) {
                    report.faceOk = false;
                    report.faceError = "API_TIMED_OUT";
                    console.log("Face Verification: " + JSON.stringify(res, null, 2));
                    resolve(report);
                    return;
                }

                //Something went wrong, not expected API response
                if (
                    !res.state.result.object ||
                    (!res.state.result.object.livenessResult &&
                        !res.state.result.object.face)
                ) {
                    report.faceOk = false;
                    report.faceError = "ERROR";
                    console.log("Face Verification: " + JSON.stringify(res, null, 2));
                    resolve(report);
                    return;
                }

                const rL = res.state.result.object.livenessResult;
                const rC = res.state.result.object.captureLiveness;
                const rM = res.state.result.object.face;
                if (rL && rL.errorCode) {
                    report.faceOk = false;
                    report.faceError = rL.errorCode;
                } else {
                    report.faceOk = (!rM || rM.result === "FACE_MATCH") &&
                        (!rL || rL.assessment === "Live") && (!rC || rC.result == "Live");
                    report.faceError += !rL
                        ? "" :
                        rL.assessment == "Live"
                            ? "Live"
                            : "NotLive";
                    report.faceError += !rC
                        ? "" :
                        rC.result == "Live"
                            ? "Valid"
                            : "Injected";
                    report.faceError += !rM
                        ? ""
                        : rM.result == "FACE_MATCH"
                            ? "_Match"
                            : "_NotMatch";
                    report.faceLiveScore =
                        "Injection: " + (!rC ? "NA" : rC.score);
                    report.faceLiveScore +=
                        ", Liveness: " + (!rL ? "NA" : rL.score);
                    report.faceMatchScore = !rM
                        ? "NA"
                        : rM.score;
                }
                resolve(report);
            });
        }
        //-----------------------------
        //------------ END ------------
        //-----------------------------

        //-----------------------------------------
        //----------- UTILITY FUNCTIONS ---------
        //-----------------------------------------

        function makeTable(tables, attachTo) {
            if (!tables) return;
            attachTo.innerHTML = "";
            for (let i = 0; i < tables.length; ++i) {
                let tableEl = document.createElement("div");
                tableEl.classList.add("table");
                attachTo.append(tableEl);
                let rowHeadEl = document.createElement("div");
                rowHeadEl.classList.add("row");
                rowHeadEl.classList.add("header");
                tableEl.append(rowHeadEl);
                let tableHeader = tables[i].header;
                if (!tableHeader) continue;
                for (let j = 0; j < tableHeader.length; ++j) {
                    let headerEl = document.createElement("div");
                    headerEl.classList.add("cell");
                    headerEl.innerHTML = tableHeader[j];
                    rowHeadEl.append(headerEl);
                }
                let rows = tables[i].rows;
                if (!rows) continue;
                for (let j = 0; j < rows.length; ++j) {
                    let rowEl = document.createElement("div");
                    rowEl.classList.add("row");
                    tableEl.append(rowEl);
                    var cols = rows[j].cols;
                    if (!cols) continue;
                    for (let k = 0; k < cols.length; ++k) {
                        let colEl = document.createElement("div");
                        colEl.classList.add("cell");
                        if (cols[k] && typeof cols[k] === "object") {
                            colEl.innerHTML = cols[k].outerHTML;
                        } else {
                            colEl.innerHTML = cols[k];
                        }
                        rowEl.append(colEl);
                    }
                }
            }
        }

        function updateText(text, header) {
            document.getElementById("maintext").innerHTML = text;
            if (header) {
                document.getElementById("mainheader").innerHTML = header;
            }
        }

        function showStart() {
            const btn = document.getElementById("mainbtn");
            const btn2 = document.getElementById("secbtn");
            const btn3 = document.getElementById("thirdbtn");
            document.getElementById("actionbox").style.display = "block";
            btn.style.display = "inline-block";
            btn2.style.display = "none";
            btn3.style.display = "none";
            document.getElementById("waitBox").style.display = "none";
            document.getElementById("OKBox").style.display = "none";
            document.getElementById("NOKBox").style.display = "none";
            document.getElementById("startBox").style.display = "block";
            btn.innerHTML = "Start";
            btn.onclick = () => {
                document.getElementById("deviceSelectorDiv").style.display = "none";
                openCamera();
            };
        }

        function showWait() {
            document.getElementById("actionbox").style.display = "block";
            document.getElementById("mainbtn").style.display = "none";
            document.getElementById("OKBox").style.display = "none";
            document.getElementById("NOKBox").style.display = "none";
            document.getElementById("startBox").style.display = "none";
            document.getElementById("secbtn").style.display = "none";
            document.getElementById("thirdbtn").style.display = "none";
            document.getElementById("verifyBox").style.display = "none";
            document.getElementById("waitBox").style.display = "block";
            document.getElementById("apiId").style.display = "none";
            document.getElementById("apiKey").style.display = "none";
        }

        function showOK() {
            const btn = document.getElementById("mainbtn");
            const btn2 = document.getElementById("secbtn");
            document.getElementById("actionbox").style.display = "block";
            document.getElementById("waitBox").style.display = "none";
            document.getElementById("NOKBox").style.display = "none";
            document.getElementById("startBox").style.display = "none";
            document.getElementById("thirdbtn").style.display = "none";
            document.getElementById("verifyBox").style.display = "none";
            document.getElementById("OKBox").style.display = "block";
            document.getElementById("apiId").style.display = "none";
            document.getElementById("apiKey").style.display = "none";
            btn.innerHTML = "Details";
            btn.onclick = () => {
                showResults(report);
                //Show table with detailed results
                document.getElementById("maintable").style.display = "block";
            };
            btn2.innerHTML = "Done";
            btn2.onclick = () => {
                showStart();
            };
            btn.style.display = "inline-block";
            btn2.style.display = "inline-block";
        }

        function showNOK() {
            const btn = document.getElementById("mainbtn");
            const btn2 = document.getElementById("secbtn");
            document.getElementById("actionbox").style.display = "block";
            document.getElementById("waitBox").style.display = "none";
            document.getElementById("OKBox").style.display = "none";
            document.getElementById("startBox").style.display = "none";
            document.getElementById("verifyBox").style.display = "none";
            document.getElementById("thirdbtn").style.display = "none";
            document.getElementById("NOKBox").style.display = "block";
            document.getElementById("apiId").style.display = "none";
            document.getElementById("apiKey").style.display = "none";
            btn.innerHTML = "Details";
            btn.onclick = () => {
                document.getElementById("maintable").style.display = "block";
            };
            btn2.innerHTML = "Done";
            btn2.onclick = () => {
                showStart();
            };
            btn.style.display = "inline-block";
            btn2.style.display = "inline-block";
        }

        function showNOKFatal() {
            const btn = document.getElementById("mainbtn");
            document.getElementById("actionbox").style.display = "block";
            btn.style.display = "inline-block";
            document.getElementById("waitBox").style.display = "none";
            document.getElementById("OKBox").style.display = "none";
            document.getElementById("startBox").style.display = "none";
            document.getElementById("secbtn").style.display = "none";
            document.getElementById("thirdbtn").style.display = "none";
            document.getElementById("verifyBox").style.display = "none";
            document.getElementById("NOKBox").style.display = "block";
            document.getElementById("apiId").style.display = "none";
            document.getElementById("apiKey").style.display = "none";
            btn.innerHTML = "Restart";
            btn.onclick = () => {
                window.location.reload();
            };
        }

        //-----------------------------
        //------------ END ------------
        //-----------------------------
    </script>
    <script async src="./idcloud.js" charset="utf-8"></script>
</body>
</html>
